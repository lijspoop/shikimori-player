// ==UserScript==
// @name            Shikimori Player
// @namespace       lijspoop/shikimori-player
// @version         1.0.0+beta1
// @author          lijspoop (https://github.com/lijspoop)
// @description     Adds players for watching anime on shikimori.one website
// @description:ru  Добавляет плееры для просмотра аниме на сайте shikimori.one
// @license         BSD-2-Clause
// @icon            https://www.google.com/s2/favicons?sz=64&domain=shikimori.one
// @downloadURL     https://github.com/lijspoop/shikimori-player/releases/latest/download/shikimori-player.user.js
// @updateURL       https://github.com/lijspoop/shikimori-player/releases/latest/download/shikimori-player.meta.js
// @match           *://*.shikimori.one/*
// @match           *://*.shikimori.me/*
// @require         https://cdn.jsdelivr.net/npm/vue@3.5.13/dist/vue.global.prod.js
// @require         https://cdn.jsdelivr.net/npm/vue-demi@latest/lib/index.iife.js
// @require         data:application/javascript,%3Bwindow.Vue%3DVue%3Bwindow.vue%3DVue%3B
// @require         https://cdn.jsdelivr.net/npm/pinia@2.3.0/dist/pinia.iife.prod.js
// @require         https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-svg-core@6.7.1/index.js
// @require         https://cdn.jsdelivr.net/npm/@fortawesome/free-solid-svg-icons@6.7.1/index.js
// @require         https://cdn.jsdelivr.net/npm/@fortawesome/free-regular-svg-icons@6.7.2/index.js
// @require         https://raw.githubusercontent.com/lijspoop/kodikwrapper/refs/heads/master/dist/index.global.prod.js
// @grant           GM_addStyle
// @grant           GM_info
// @grant           GM_xmlhttpRequest
// @run-at          document-start
// ==/UserScript==

(i => { if (typeof GM_addStyle == "function") { GM_addStyle(i); return } const e = document.createElement("style"); e.textContent = i, document.head.append(e) })(' :root{--sp-background: url(/assets/background/square_bg.png);--sp-active-btn-clr: #456;--sp-inactive-btn-clr: #8697a7;--sp-transition-color: color .25s ease;--sp-main-indent: 5px;--sp-main-size: 32px}.boop{--transition-color: inherit;--padding-main: 4px;--padding-icon: 8.5px}.p-animes-show .shiki-player .tiny{font-size:11px}.p-animes-show .shiki-player :not(.stat_name)>:not(.active,:hover,.disabled)>.size{color:var(--color-text-hint, #777);margin-left:auto}.p-animes-show .shiki-player .sp-buttons{display:flex;gap:12px}.p-animes-show .shiki-player .sp-buttons.group{gap:0}.p-animes-show .shiki-player .sp-buttons.stretch>.b-link_button:not(.is-icon),.p-animes-show .shiki-player .sp-buttons.stretch>.sp-buttons{flex:1 0 0}.p-animes-show .shiki-player .b-link_button{white-space:nowrap;display:inline-flex;gap:8px;margin:0;padding:4px 1rem;flex-shrink:0;justify-content:center;align-items:center;min-width:1px;position:relative;text-align:center}.p-animes-show .shiki-player .b-link_button .fa-eye,.p-animes-show .shiki-player .b-link_button .fa-bookmark,.p-animes-show .shiki-player .b-link_button .number{-webkit-transition:var(--transition-color);transition:var(--transition-color)}.p-animes-show .shiki-player .b-link_button .fa-eye,.p-animes-show .shiki-player .b-link_button .fa-bookmark{color:var(--color-text-hint, #777)}.p-animes-show .shiki-player .b-link_button.watched .fa-bookmark{color:var(--color-primary-hovered, #4c86c8)}.p-animes-show .shiki-player .b-link_button.watched.dark .fa-bookmark{color:var(--color-text-on-primary, #4c86c8)}.p-animes-show .shiki-player .b-link_button:hover .fa-eye,.p-animes-show .shiki-player .b-link_button:hover .fa-bookmark{color:inherit}.p-animes-show .shiki-player .sp-buttons .b-link_button{min-width:32px}.p-animes-show .shiki-player .sp-buttons .b-link_button:first-child{border-radius:var(--border-rounded, 0) 0 0 var(--border-rounded, 0)}.p-animes-show .shiki-player .sp-buttons .b-link_button:last-child{border-radius:0 var(--border-rounded, 0) var(--border-rounded, 0) 0}.p-animes-show .shiki-player .sp-buttons .b-link_button.is-icon{padding:var(--padding-icon, 4px)}.p-animes-show .shiki-player .sp-buttons .b-link_button.is-icon.size-lg{height:32px;line-height:32px}.p-animes-show .shiki-player .sp-buttons .b-link_button.is-icon .icon{display:flex;align-items:center}.p-animes-show .shiki-player .sp-container{display:flex}.p-animes-show .shiki-player .sp-container.sp-content{max-height:496px;height:359px;min-height:359px}.p-animes-show .shiki-player .sp-container.sp-content.max-height{height:496px}.p-animes-show .shiki-player .sp-container .sp-viewport{width:100%;background:var(--sp-background);position:relative;-webkit-backdrop-filter:sepia(1) contrast(.5) hue-rotate(125deg);backdrop-filter:sepia(1) contrast(.5) hue-rotate(125deg)}.p-animes-show .shiki-player .sp-container .sp-viewport_iframe{height:100%;width:100%;position:absolute}.p-animes-show .shiki-player .sp-container .sp-viewport_buttons{display:flex;position:absolute;top:8px;right:8px;z-index:10;overflow:hidden;transition:opacity .3s ease;opacity:0}.p-animes-show .shiki-player .sp-container .sp-viewport_buttons .b-link_button{z-index:3}.p-animes-show .shiki-player .sp-container .sp-viewport_buttons .b-link_button.is-icon{padding-left:0;padding-right:0;width:30px}.p-animes-show .shiki-player .sp-container .sp-viewport_buttons .b-link_button.is-icon.size-lg{height:32px;line-height:32px}.p-animes-show .shiki-player .sp-container .sp-viewport_buttons.visible,.p-animes-show .shiki-player .sp-container .sp-viewport:hover .sp-viewport_buttons{opacity:1}.p-animes-show .shiki-player .sp-container .sp-sidebar{width:242px;position:relative;display:flex;flex-shrink:0;flex-direction:column;padding-left:var(--sp-main-indent)}.p-animes-show .shiki-player .sp-container .sp-sidebar .sp-selection_panel{flex-grow:1;display:flex;flex-direction:column;min-height:1px}.p-animes-show .shiki-player .sp-container .sp-sidebar .sp-selection_panel .sp-balancers{margin-bottom:var(--sp-main-indent)}.p-animes-show .shiki-player .sp-container .sp-sidebar .sp-selection_panel .sp-balancers .title{color:var(--color-text-hint, #123);font-weight:700}.p-animes-show .shiki-player .sp-container .sp-sidebar .sp-selection_panel .sp-balancers .list .b-tag.active{background-color:var(--color-primary-hovered, #456);color:var(--color-text-on-primary, #fff);cursor:default}.p-animes-show .shiki-player .sp-container .sp-sidebar .sp-selection_panel .sp-balancers .list .b-tag.disabled{color:var(--sp-inactive-btn-clr)}.p-animes-show .shiki-player .sp-container .sp-sidebar .sp-selection_panel .sp-translations{overflow-y:auto}.p-animes-show .shiki-player .sp-container .sp-sidebar .sp-selection_panel .sp-translations .inner{display:flex;justify-content:space-between;flex-direction:column;gap:2px}.p-animes-show .shiki-player .sp-container .sp-sidebar .sp-selection_panel .sp-translations .inner .b-link:hover{text-decoration:none}.p-animes-show .shiki-player .sp-container .sp-sidebar .sp-selection_panel .sp-translations .inner .b-link.active{color:var(--link-hover-color);text-decoration:underline}.p-animes-show .shiki-player .sp-container .sp-sidebar .sp-selection_panel .sp-translations .inner .b-menu-line.entry{line-height:1.5rem}.p-animes-show .shiki-player .sp-container .sp-sidebar .sp-selection_panel .sp-translations .inner .b-menu-line.entry:hover .name{text-decoration:underline}.p-animes-show .shiki-player .sp-container .sp-sidebar .sp-selection_panel .sp-translations .inner .b-menu-line.entry .size{float:right;padding:0 5px}.p-animes-show .shiki-player .sp-container .sp-sidebar .sp-selection_panel .sp-tabs{min-height:initial}.p-animes-show .shiki-player .sp-container .sp-sidebar .sp-selection_panel .sp-tabs .stat_names .stat_name>a:not(.active):has(.size:not([data-total="0"])):before{background-color:var(--color-primary-reduced)}.p-animes-show .shiki-player .sp-container .sp-sidebar .sp-selection_panel .sp-tabs .stat_names .stat_name>a.active{color:var(--link-hover-color)}.p-animes-show .shiki-player .sp-container .sp-sidebar .sp-selection_panel .sp-tabs .stat_names .stat_name>a.active:before{background-color:var(--color-primary)}.p-animes-show .shiki-player .sp-container .sp-sidebar .sp-selection_panel .sp-tabs .b-link_button{min-width:unset;margin:0}.p-animes-show .shiki-player .sp-container .sp-sidebar .sp-selection_panel .b-stats_bar .stat_names .stat_name .size{margin-left:3px}.p-animes-show .shiki-player .sp-container .sp-sidebar>.sp-buttons>.sp-buttons{margin-top:var(--sp-main-indent)}.p-animes-show .shiki-player .sp-container .sp-sidebar>.sp-buttons .b-link_button{margin:0;min-width:1px;width:inherit}.p-animes-show .shiki-player .sp-container[data-player-sidebar=hidden] .sp-sidebar{display:none}.p-animes-show .shiki-player .sp-episodes{position:relative;display:flex;align-items:center;width:100%;padding:var(--sp-main-indent) 0}.p-animes-show .shiki-player .sp-episodes_buttons{display:flex;flex-shrink:0;margin-right:var(--sp-main-indent)}.p-animes-show .shiki-player .sp-episodes_buttons.sp-buttons .b-link_button{border-radius:var(--border-rounded, 0)}.p-animes-show .shiki-player .sp-episodes_search{flex-shrink:0;display:flex;align-items:center;margin-right:var(--sp-main-indent);width:200px}.p-animes-show .shiki-player .sp-episodes_search_input{position:relative;flex-grow:1}.p-animes-show .shiki-player .sp-episodes_search_input:has(.found-episodes) .b-input input{--padding-right: 36px}.p-animes-show .shiki-player .sp-episodes_search_input .b-input{position:relative;flex-grow:1;margin:0}.p-animes-show .shiki-player .sp-episodes_search_input .b-input input{position:relative;line-height:inherit;min-height:24px;max-width:200px;padding:var(--padding-main, .785px) 10px;padding-right:var(--padding-right);border-top-right-radius:0;border-bottom-right-radius:0}.p-animes-show .shiki-player .sp-episodes_search_input .b-input input::-webkit-outer-spin-button,.p-animes-show .shiki-player .sp-episodes_search_input .b-input input::-webkit-inner-spin-button{-webkit-appearance:none;margin:0}.p-animes-show .shiki-player .sp-episodes_search_input .found-episodes{position:absolute;top:0;right:0;z-index:6;display:flex;align-items:center;height:100%;padding:0 8px;font-size:12px;box-sizing:border-box;color:#8a8a8e;color:var(--text-secondary);pointer-events:none}.p-animes-show .shiki-player .sp-episodes_search_buttons .b-link_button,.p-animes-show .shiki-player .sp-episodes_search_buttons .b-link_button:first-child{border-radius:0}.p-animes-show .shiki-player .sp-episodes_container{min-width:1px;position:relative;z-index:2}.p-animes-show .shiki-player .sp-episodes_container .arrow{position:absolute;top:0;bottom:0;z-index:6;display:flex;align-items:center;justify-content:center;padding:8px;cursor:pointer}.p-animes-show .shiki-player .sp-episodes_container .arrow.left{left:0;background:linear-gradient(to right,var(--color-surface, #fff) 50%,transparent);padding-right:14px}.p-animes-show .shiki-player .sp-episodes_container .arrow.right{right:0;background:linear-gradient(to left,var(--color-surface, #fff) 50%,transparent);padding-left:14px}.p-animes-show .shiki-player .sp-episodes_container .arrow.is-icon .icon{transition:background .3s ease,transform .3s ease}.p-animes-show .shiki-player .sp-episodes_container .arrow.left:hover .icon{transform:translate(-4px)}.p-animes-show .shiki-player .sp-episodes_container .arrow.right:hover .icon{transform:translate(4px)}.p-animes-show .shiki-player .sp-episodes_container .inner{overflow-x:auto;display:flex;justify-content:space-between;gap:var(--sp-main-indent);scrollbar-width:none;-ms-overflow-style:none}.p-animes-show .shiki-player .sp-episodes_container .inner .b-link_button.highlight span{background:#8a2be2;color:#fff;padding-left:2px;padding-right:2px;font-weight:600}.p-animes-show .shiki-player .sp-episodes .fade-enter-active,.p-animes-show .shiki-player .sp-episodes .fade-leave-active{transition:opacity .5s}.p-animes-show .shiki-player .sp-episodes .fade-enter,.p-animes-show .shiki-player .sp-episodes .fade-leave-to{opacity:0}.p-animes-show .shiki-player .sp-footer .script-info{color:var(--color-text-disabled, #9da2a8);cursor:default;font-size:12px}.p-animes-show .shiki-player .disabled,.p-animes-show .shiki-player .disabled :before,.p-animes-show .shiki-player .disabled :after{cursor:not-allowed!important} ');

(function (vue, pinia, fontawesomeSvgCore, freeSolidSvgIcons, kodikwrapper, freeRegularSvgIcons) {
    'use strict';

    var Vn = Object.defineProperty; var qn = (e, t, n) => t in e ? Vn(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n; var ce = (e, t, n) => qn(e, typeof t != "symbol" ? t + "" : t, n); var $t = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};/*! *****************************************************************************
  Copyright (C) Microsoft. All rights reserved.
  Licensed under the Apache License, Version 2.0 (the "License"); you may not use
  this file except in compliance with the License. You may obtain a copy of the
  License at http://www.apache.org/licenses/LICENSE-2.0

  THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
  WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
  MERCHANTABLITY OR NON-INFRINGEMENT.

  See the Apache Version 2.0 License for specific language governing permissions
  and limitations under the License.
  ***************************************************************************** */var Ut; (function (e) { (function (t) { var n = typeof globalThis == "object" ? globalThis : typeof $t == "object" ? $t : typeof self == "object" ? self : typeof this == "object" ? this : c(), r = i(e); typeof n.Reflect < "u" && (r = i(n.Reflect, r)), t(r, n), typeof n.Reflect > "u" && (n.Reflect = e); function i(l, f) { return function (u, y) { Object.defineProperty(l, u, { configurable: !0, writable: !0, value: y }), f && f(u, y); } } function s() { try { return Function("return this;")() } catch { } } function a() { try { return (0, eval)("(function() { return this; })()") } catch { } } function c() { return s() || a() } })(function (t, n) { var r = Object.prototype.hasOwnProperty, i = typeof Symbol == "function", s = i && typeof Symbol.toPrimitive < "u" ? Symbol.toPrimitive : "@@toPrimitive", a = i && typeof Symbol.iterator < "u" ? Symbol.iterator : "@@iterator", c = typeof Object.create == "function", l = { __proto__: [] } instanceof Array, f = !c && !l, u = { create: c ? function () { return ot(Object.create(null)) } : l ? function () { return ot({ __proto__: null }) } : function () { return ot({}) }, has: f ? function (o, d) { return r.call(o, d) } : function (o, d) { return d in o }, get: f ? function (o, d) { return r.call(o, d) ? o[d] : void 0 } : function (o, d) { return o[d] } }, y = Object.getPrototypeOf(Function), m = typeof Map == "function" && typeof Map.prototype.entries == "function" ? Map : Fn(), I = typeof Set == "function" && typeof Set.prototype.entries == "function" ? Set : Bn(), k = typeof WeakMap == "function" ? WeakMap : jn(), D = i ? Symbol.for("@reflect-metadata:registry") : void 0, G = Rn(), v = Mn(G); function b(o, d, p, _) { if (A(p)) { if (!It(o)) throw new TypeError; if (!At(d)) throw new TypeError; return he(o, d) } else { if (!It(o)) throw new TypeError; if (!Q(d)) throw new TypeError; if (!Q(_) && !A(_) && !Se(_)) throw new TypeError; return Se(_) && (_ = void 0), p = fe(p), _e(o, d, p, _) } } t("decorate", b); function C(o, d) { function p(_, S) { if (!Q(_)) throw new TypeError; if (!A(S) && !Dn(S)) throw new TypeError; we(o, d, _, S); } return p } t("metadata", C); function j(o, d, p, _) { if (!Q(p)) throw new TypeError; return A(_) || (_ = fe(_)), we(o, d, p, _) } t("defineMetadata", j); function te(o, d, p) { if (!Q(d)) throw new TypeError; return A(p) || (p = fe(p)), Ee(o, d, p) } t("hasMetadata", te); function w(o, d, p) { if (!Q(d)) throw new TypeError; return A(p) || (p = fe(p)), Oe(o, d, p) } t("hasOwnMetadata", w); function B(o, d, p) { if (!Q(d)) throw new TypeError; return A(p) || (p = fe(p)), Re(o, d, p) } t("getMetadata", B); function ne(o, d, p) { if (!Q(d)) throw new TypeError; return A(p) || (p = fe(p)), ge(o, d, p) } t("getOwnMetadata", ne); function oe(o, d) { if (!Q(o)) throw new TypeError; return A(d) || (d = fe(d)), ze(o, d) } t("getMetadataKeys", oe); function qe(o, d) { if (!Q(o)) throw new TypeError; return A(d) || (d = fe(d)), se(o, d) } t("getOwnMetadataKeys", qe); function ke(o, d, p) { if (!Q(d)) throw new TypeError; if (A(p) || (p = fe(p)), !Q(d)) throw new TypeError; A(p) || (p = fe(p)); var _ = Me(d, p, !1); return A(_) ? !1 : _.OrdinaryDeleteMetadata(o, d, p) } t("deleteMetadata", ke); function he(o, d) { for (var p = o.length - 1; p >= 0; --p) { var _ = o[p], S = _(d); if (!A(S) && !Se(S)) { if (!At(S)) throw new TypeError; d = S; } } return d } function _e(o, d, p, _) { for (var S = o.length - 1; S >= 0; --S) { var K = o[S], X = K(d, p, _); if (!A(X) && !Se(X)) { if (!Q(X)) throw new TypeError; _ = X; } } return _ } function Ee(o, d, p) { var _ = Oe(o, d, p); if (_) return !0; var S = at(d); return Se(S) ? !1 : Ee(o, S, p) } function Oe(o, d, p) { var _ = Me(d, p, !1); return A(_) ? !1 : xt(_.OrdinaryHasOwnMetadata(o, d, p)) } function Re(o, d, p) { var _ = Oe(o, d, p); if (_) return ge(o, d, p); var S = at(d); if (!Se(S)) return Re(o, S, p) } function ge(o, d, p) { var _ = Me(d, p, !1); if (!A(_)) return _.OrdinaryGetOwnMetadata(o, d, p) } function we(o, d, p, _) { var S = Me(p, _, !0); S.OrdinaryDefineOwnMetadata(o, d, p, _); } function ze(o, d) { var p = se(o, d), _ = at(o); if (_ === null) return p; var S = ze(_, d); if (S.length <= 0) return p; if (p.length <= 0) return S; for (var K = new I, X = [], M = 0, E = p; M < E.length; M++) { var g = E[M], T = K.has(g); T || (K.add(g), X.push(g)); } for (var O = 0, P = S; O < P.length; O++) { var g = P[O], T = K.has(g); T || (K.add(g), X.push(g)); } return X } function se(o, d) { var p = Me(o, d, !1); return p ? p.OrdinaryOwnMetadataKeys(o, d) : [] } function ve(o) { if (o === null) return 1; switch (typeof o) { case "undefined": return 0; case "boolean": return 2; case "string": return 3; case "symbol": return 4; case "number": return 5; case "object": return o === null ? 1 : 6; default: return 6 } } function A(o) { return o === void 0 } function Se(o) { return o === null } function xn(o) { return typeof o == "symbol" } function Q(o) { return typeof o == "object" ? o !== null : typeof o == "function" } function In(o, d) { switch (ve(o)) { case 0: return o; case 1: return o; case 2: return o; case 3: return o; case 4: return o; case 5: return o }var p = "string", _ = Ct(o, s); if (_ !== void 0) { var S = _.call(o, p); if (Q(S)) throw new TypeError; return S } return An(o) } function An(o, d) { var p, _; { var S = o.toString; if (Ge(S)) { var _ = S.call(o); if (!Q(_)) return _ } var p = o.valueOf; if (Ge(p)) { var _ = p.call(o); if (!Q(_)) return _ } } throw new TypeError } function xt(o) { return !!o } function Cn(o) { return "" + o } function fe(o) { var d = In(o); return xn(d) ? d : Cn(d) } function It(o) { return Array.isArray ? Array.isArray(o) : o instanceof Object ? o instanceof Array : Object.prototype.toString.call(o) === "[object Array]" } function Ge(o) { return typeof o == "function" } function At(o) { return typeof o == "function" } function Dn(o) { switch (ve(o)) { case 3: return !0; case 4: return !0; default: return !1 } } function st(o, d) { return o === d || o !== o && d !== d } function Ct(o, d) { var p = o[d]; if (p != null) { if (!Ge(p)) throw new TypeError; return p } } function Dt(o) { var d = Ct(o, a); if (!Ge(d)) throw new TypeError; var p = d.call(o); if (!Q(p)) throw new TypeError; return p } function Lt(o) { return o.value } function Rt(o) { var d = o.next(); return d.done ? !1 : d } function Mt(o) { var d = o.return; d && d.call(o); } function at(o) { var d = Object.getPrototypeOf(o); if (typeof o != "function" || o === y || d !== y) return d; var p = o.prototype, _ = p && Object.getPrototypeOf(p); if (_ == null || _ === Object.prototype) return d; var S = _.constructor; return typeof S != "function" || S === o ? d : S } function Ln() { var o; !A(D) && typeof n.Reflect < "u" && !(D in n.Reflect) && typeof n.Reflect.defineMetadata == "function" && (o = Pn(n.Reflect)); var d, p, _, S = new k, K = { registerProvider: X, getProvider: E, setProvider: T }; return K; function X(O) { if (!Object.isExtensible(K)) throw new Error("Cannot add provider to a frozen registry."); switch (!0) { case o === O: break; case A(d): d = O; break; case d === O: break; case A(p): p = O; break; case p === O: break; default: _ === void 0 && (_ = new I), _.add(O); break } } function M(O, P) { if (!A(d)) { if (d.isProviderFor(O, P)) return d; if (!A(p)) { if (p.isProviderFor(O, P)) return d; if (!A(_)) for (var z = Dt(_); ;) { var Y = Rt(z); if (!Y) return; var le = Lt(Y); if (le.isProviderFor(O, P)) return Mt(z), le } } } if (!A(o) && o.isProviderFor(O, P)) return o } function E(O, P) { var z = S.get(O), Y; return A(z) || (Y = z.get(P)), A(Y) && (Y = M(O, P), A(Y) || (A(z) && (z = new m, S.set(O, z)), z.set(P, Y))), Y } function g(O) { if (A(O)) throw new TypeError; return d === O || p === O || !A(_) && _.has(O) } function T(O, P, z) { if (!g(z)) throw new Error("Metadata provider not registered."); var Y = E(O, P); if (Y !== z) { if (!A(Y)) return !1; var le = S.get(O); A(le) && (le = new m, S.set(O, le)), le.set(P, z); } return !0 } } function Rn() { var o; return !A(D) && Q(n.Reflect) && Object.isExtensible(n.Reflect) && (o = n.Reflect[D]), A(o) && (o = Ln()), !A(D) && Q(n.Reflect) && Object.isExtensible(n.Reflect) && Object.defineProperty(n.Reflect, D, { enumerable: !1, configurable: !1, writable: !1, value: o }), o } function Mn(o) { var d = new k, p = { isProviderFor: function (g, T) { var O = d.get(g); return A(O) ? !1 : O.has(T) }, OrdinaryDefineOwnMetadata: X, OrdinaryHasOwnMetadata: S, OrdinaryGetOwnMetadata: K, OrdinaryOwnMetadataKeys: M, OrdinaryDeleteMetadata: E }; return G.registerProvider(p), p; function _(g, T, O) { var P = d.get(g), z = !1; if (A(P)) { if (!O) return; P = new m, d.set(g, P), z = !0; } var Y = P.get(T); if (A(Y)) { if (!O) return; if (Y = new m, P.set(T, Y), !o.setProvider(g, T, p)) throw P.delete(T), z && d.delete(g), new Error("Wrong provider for target.") } return Y } function S(g, T, O) { var P = _(T, O, !1); return A(P) ? !1 : xt(P.has(g)) } function K(g, T, O) { var P = _(T, O, !1); if (!A(P)) return P.get(g) } function X(g, T, O, P) { var z = _(O, P, !0); z.set(g, T); } function M(g, T) { var O = [], P = _(g, T, !1); if (A(P)) return O; for (var z = P.keys(), Y = Dt(z), le = 0; ;) { var Pt = Rt(Y); if (!Pt) return O.length = le, O; var $n = Lt(Pt); try { O[le] = $n; } catch (Un) { try { Mt(Y); } finally { throw Un } } le++; } } function E(g, T, O) { var P = _(T, O, !1); if (A(P) || !P.delete(g)) return !1; if (P.size === 0) { var z = d.get(T); A(z) || (z.delete(O), z.size === 0 && d.delete(z)); } return !0 } } function Pn(o) { var d = o.defineMetadata, p = o.hasOwnMetadata, _ = o.getOwnMetadata, S = o.getOwnMetadataKeys, K = o.deleteMetadata, X = new k, M = { isProviderFor: function (E, g) { var T = X.get(E); return !A(T) && T.has(g) ? !0 : S(E, g).length ? (A(T) && (T = new I, X.set(E, T)), T.add(g), !0) : !1 }, OrdinaryDefineOwnMetadata: d, OrdinaryHasOwnMetadata: p, OrdinaryGetOwnMetadata: _, OrdinaryOwnMetadataKeys: S, OrdinaryDeleteMetadata: K }; return M } function Me(o, d, p) { var _ = G.getProvider(o, d); if (!A(_)) return _; if (p) { if (G.setProvider(o, d, v)) return v; throw new Error("Illegal state.") } } function Fn() { var o = {}, d = [], p = function () { function M(E, g, T) { this._index = 0, this._keys = E, this._values = g, this._selector = T; } return M.prototype["@@iterator"] = function () { return this }, M.prototype[a] = function () { return this }, M.prototype.next = function () { var E = this._index; if (E >= 0 && E < this._keys.length) { var g = this._selector(this._keys[E], this._values[E]); return E + 1 >= this._keys.length ? (this._index = -1, this._keys = d, this._values = d) : this._index++, { value: g, done: !1 } } return { value: void 0, done: !0 } }, M.prototype.throw = function (E) { throw this._index >= 0 && (this._index = -1, this._keys = d, this._values = d), E }, M.prototype.return = function (E) { return this._index >= 0 && (this._index = -1, this._keys = d, this._values = d), { value: E, done: !0 } }, M }(), _ = function () { function M() { this._keys = [], this._values = [], this._cacheKey = o, this._cacheIndex = -2; } return Object.defineProperty(M.prototype, "size", { get: function () { return this._keys.length }, enumerable: !0, configurable: !0 }), M.prototype.has = function (E) { return this._find(E, !1) >= 0 }, M.prototype.get = function (E) { var g = this._find(E, !1); return g >= 0 ? this._values[g] : void 0 }, M.prototype.set = function (E, g) { var T = this._find(E, !0); return this._values[T] = g, this }, M.prototype.delete = function (E) { var g = this._find(E, !1); if (g >= 0) { for (var T = this._keys.length, O = g + 1; O < T; O++)this._keys[O - 1] = this._keys[O], this._values[O - 1] = this._values[O]; return this._keys.length--, this._values.length--, st(E, this._cacheKey) && (this._cacheKey = o, this._cacheIndex = -2), !0 } return !1 }, M.prototype.clear = function () { this._keys.length = 0, this._values.length = 0, this._cacheKey = o, this._cacheIndex = -2; }, M.prototype.keys = function () { return new p(this._keys, this._values, S) }, M.prototype.values = function () { return new p(this._keys, this._values, K) }, M.prototype.entries = function () { return new p(this._keys, this._values, X) }, M.prototype["@@iterator"] = function () { return this.entries() }, M.prototype[a] = function () { return this.entries() }, M.prototype._find = function (E, g) { if (!st(this._cacheKey, E)) { this._cacheIndex = -1; for (var T = 0; T < this._keys.length; T++)if (st(this._keys[T], E)) { this._cacheIndex = T; break } } return this._cacheIndex < 0 && g && (this._cacheIndex = this._keys.length, this._keys.push(E), this._values.push(void 0)), this._cacheIndex }, M }(); return _; function S(M, E) { return M } function K(M, E) { return E } function X(M, E) { return [M, E] } } function Bn() { var o = function () { function d() { this._map = new m; } return Object.defineProperty(d.prototype, "size", { get: function () { return this._map.size }, enumerable: !0, configurable: !0 }), d.prototype.has = function (p) { return this._map.has(p) }, d.prototype.add = function (p) { return this._map.set(p, p), this }, d.prototype.delete = function (p) { return this._map.delete(p) }, d.prototype.clear = function () { this._map.clear(); }, d.prototype.keys = function () { return this._map.keys() }, d.prototype.values = function () { return this._map.keys() }, d.prototype.entries = function () { return this._map.entries() }, d.prototype["@@iterator"] = function () { return this.keys() }, d.prototype[a] = function () { return this.keys() }, d }(); return o } function jn() { var o = 16, d = u.create(), p = _(); return function () { function E() { this._key = _(); } return E.prototype.has = function (g) { var T = S(g, !1); return T !== void 0 ? u.has(T, this._key) : !1 }, E.prototype.get = function (g) { var T = S(g, !1); return T !== void 0 ? u.get(T, this._key) : void 0 }, E.prototype.set = function (g, T) { var O = S(g, !0); return O[this._key] = T, this }, E.prototype.delete = function (g) { var T = S(g, !1); return T !== void 0 ? delete T[this._key] : !1 }, E.prototype.clear = function () { this._key = _(); }, E }(); function _() { var E; do E = "@@WeakMap@@" + M(); while (u.has(d, E)); return d[E] = !0, E } function S(E, g) { if (!r.call(E, p)) { if (!g) return; Object.defineProperty(E, p, { value: u.create() }); } return E[p] } function K(E, g) { for (var T = 0; T < g; ++T)E[T] = Math.random() * 255 | 0; return E } function X(E) { if (typeof Uint8Array == "function") { var g = new Uint8Array(E); return typeof crypto < "u" ? crypto.getRandomValues(g) : typeof msCrypto < "u" ? msCrypto.getRandomValues(g) : K(g, E), g } return K(new Array(E), E) } function M() { var E = X(o); E[6] = E[6] & 79 | 64, E[8] = E[8] & 191 | 128; for (var g = "", T = 0; T < o; ++T) { var O = E[T]; (T === 4 || T === 6 || T === 8) && (g += "-"), O < 16 && (g += "0"), g += O.toString(16).toLowerCase(); } return g } } function ot(o) { return o.__ = void 0, delete o.__, o } }); })(Ut || (Ut = {})); var fi = Object.defineProperty, Fe = (e, t) => fi(e, "name", { value: t, configurable: !0 }); function fn(e) { var s; (s = e.init) == null || s.call(e), "events" in e && Array.isArray(e.events) && t(e.events); function t(a, c = void 0) { a == null || a.forEach(l => { c !== void 0 && (l.parentEvent = c), Array.isArray(l.type) ? l.type.forEach(f => n(f, l)) : n(l.type, l); }); } Fe(t, "handlerEvents"); function n(a, c) { let l = r(c), f = c.target; if (console.assert(!!f, "Не указано к чему присоединить слушатель событий."), console.assert(!!a, "Не указан тип события."), Array.isArray(a) && a[0] === "attachEvent") (document.attachEvent ? document.readyState === "complete" : document.readyState !== "loading") ? l() : typeof a[1] == "string" && f.addEventListener(a[1], l, c == null ? void 0 : c.options); else if (typeof a == "function") { let u = a(l); typeof u == "function" || typeof u == "boolean" && u ? l() : typeof u == "string" ? f.addEventListener(u, l, c == null ? void 0 : c.options) : Array.isArray(u) ? f.addEventListener(u[0], u[1], u == null ? void 0 : u[2]) : typeof u == "object" && Object.hasOwn(u, "type") && n(u.type, u); } else typeof a == "string" && f.addEventListener(a, l, c == null ? void 0 : c.options); } Fe(n, "registerEventListener"); function r(a) { return function (c) { i(a == null ? void 0 : a.preconditions) || !Object.hasOwn(a, "parentEvent") && i(e == null ? void 0 : e.preconditions) || (Object.hasOwn(a, "listener") ? typeof (a == null ? void 0 : a.listener) == "function" && a.listener(c, a == null ? void 0 : a.parentEvent) : console.warn("listener не указан", a), t(a == null ? void 0 : a.children, a)); } } Fe(r, "setListener"); function i(a) { var c, l; return !!(a && ((c = a == null ? void 0 : a.predicates) != null && c.some(f => !f(a == null ? void 0 : a.paths)) || (l = a == null ? void 0 : a.paths) != null && l.some(f => !window.location.href.match(f)))) } Fe(i, "preventByCondition"); } Fe(fn, "defineHandler"); function Vt(e, t) { var n = Object.keys(e); if (Object.getOwnPropertySymbols) { var r = Object.getOwnPropertySymbols(e); t && (r = r.filter(function (i) { return Object.getOwnPropertyDescriptor(e, i).enumerable })), n.push.apply(n, r); } return n } function de(e) { for (var t = 1; t < arguments.length; t++) { var n = arguments[t] != null ? arguments[t] : {}; t % 2 ? Vt(Object(n), !0).forEach(function (r) { re(e, r, n[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Vt(Object(n)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r)); }); } return e } function pi(e, t) { if (typeof e != "object" || !e) return e; var n = e[Symbol.toPrimitive]; if (n !== void 0) { var r = n.call(e, t || "default"); if (typeof r != "object") return r; throw new TypeError("@@toPrimitive must return a primitive value.") } return (t === "string" ? String : Number)(e) } function hi(e) { var t = pi(e, "string"); return typeof t == "symbol" ? t : t + "" } function Ze(e) { "@babel/helpers - typeof"; return Ze = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function (t) { return typeof t } : function (t) { return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t }, Ze(e) } function re(e, t, n) { return t = hi(t), t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e } function mi(e, t) { if (e == null) return {}; var n = {}; for (var r in e) if (Object.prototype.hasOwnProperty.call(e, r)) { if (t.indexOf(r) >= 0) continue; n[r] = e[r]; } return n } function vi(e, t) { if (e == null) return {}; var n = mi(e, t), r, i; if (Object.getOwnPropertySymbols) { var s = Object.getOwnPropertySymbols(e); for (i = 0; i < s.length; i++)r = s[i], !(t.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(e, r) && (n[r] = e[r]); } return n } function ht(e) { return yi(e) || _i(e) || Ei(e) || gi() } function yi(e) { if (Array.isArray(e)) return mt(e) } function _i(e) { if (typeof Symbol < "u" && e[Symbol.iterator] != null || e["@@iterator"] != null) return Array.from(e) } function Ei(e, t) { if (e) { if (typeof e == "string") return mt(e, t); var n = Object.prototype.toString.call(e).slice(8, -1); if (n === "Object" && e.constructor && (n = e.constructor.name), n === "Map" || n === "Set") return Array.from(e); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return mt(e, t) } } function mt(e, t) { (t == null || t > e.length) && (t = e.length); for (var n = 0, r = new Array(t); n < t; n++)r[n] = e[n]; return r } function gi() {
        throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
    } var bi = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {}, pn = { exports: {} }; (function (e) { (function (t) { var n = function (v, b, C) { if (!f(b) || y(b) || m(b) || I(b) || l(b)) return b; var j, te = 0, w = 0; if (u(b)) for (j = [], w = b.length; te < w; te++)j.push(n(v, b[te], C)); else { j = {}; for (var B in b) Object.prototype.hasOwnProperty.call(b, B) && (j[v(B, C)] = n(v, b[B], C)); } return j }, r = function (v, b) { b = b || {}; var C = b.separator || "_", j = b.split || /(?=[A-Z])/; return v.split(j).join(C) }, i = function (v) { return k(v) ? v : (v = v.replace(/[\-_\s]+(.)?/g, function (b, C) { return C ? C.toUpperCase() : "" }), v.substr(0, 1).toLowerCase() + v.substr(1)) }, s = function (v) { var b = i(v); return b.substr(0, 1).toUpperCase() + b.substr(1) }, a = function (v, b) { return r(v, b).toLowerCase() }, c = Object.prototype.toString, l = function (v) { return typeof v == "function" }, f = function (v) { return v === Object(v) }, u = function (v) { return c.call(v) == "[object Array]" }, y = function (v) { return c.call(v) == "[object Date]" }, m = function (v) { return c.call(v) == "[object RegExp]" }, I = function (v) { return c.call(v) == "[object Boolean]" }, k = function (v) { return v = v - 0, v === v }, D = function (v, b) { var C = b && "process" in b ? b.process : b; return typeof C != "function" ? v : function (j, te) { return C(j, v, te) } }, G = { camelize: i, decamelize: a, pascalize: s, depascalize: a, camelizeKeys: function (v, b) { return n(D(i, b), v) }, decamelizeKeys: function (v, b) { return n(D(a, b), v, b) }, pascalizeKeys: function (v, b) { return n(D(s, b), v) }, depascalizeKeys: function () { return this.decamelizeKeys.apply(this, arguments) } }; e.exports ? e.exports = G : t.humps = G; })(bi); })(pn); var Ti = pn.exports, Ni = ["class", "style"]; function ki(e) { return e.split(";").map(function (t) { return t.trim() }).filter(function (t) { return t }).reduce(function (t, n) { var r = n.indexOf(":"), i = Ti.camelize(n.slice(0, r)), s = n.slice(r + 1).trim(); return t[i] = s, t }, {}) } function Oi(e) { return e.split(/\s+/).reduce(function (t, n) { return t[n] = !0, t }, {}) } function Nt(e) { var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}; if (typeof e == "string") return e; var r = (e.children || []).map(function (l) { return Nt(l) }), i = Object.keys(e.attributes || {}).reduce(function (l, f) { var u = e.attributes[f]; switch (f) { case "class": l.class = Oi(u); break; case "style": l.style = ki(u); break; default: l.attrs[f] = u; }return l }, { attrs: {}, class: {}, style: {} }); n.class; var s = n.style, a = s === void 0 ? {} : s, c = vi(n, Ni); return vue.h(e.tag, de(de(de({}, t), {}, { class: i.class, style: de(de({}, i.style), a) }, i.attrs), c), r) } var hn = !1; try { hn = !0; } catch { } function wi() { if (!hn && console && typeof console.error == "function") { var e; (e = console).error.apply(e, arguments); } } function je(e, t) { return Array.isArray(t) && t.length > 0 || !Array.isArray(t) && t ? re({}, e, t) : {} } function Si(e) { var t, n = (t = { "fa-spin": e.spin, "fa-pulse": e.pulse, "fa-fw": e.fixedWidth, "fa-border": e.border, "fa-li": e.listItem, "fa-inverse": e.inverse, "fa-flip": e.flip === !0, "fa-flip-horizontal": e.flip === "horizontal" || e.flip === "both", "fa-flip-vertical": e.flip === "vertical" || e.flip === "both" }, re(re(re(re(re(re(re(re(re(re(t, "fa-".concat(e.size), e.size !== null), "fa-rotate-".concat(e.rotation), e.rotation !== null), "fa-pull-".concat(e.pull), e.pull !== null), "fa-swap-opacity", e.swapOpacity), "fa-bounce", e.bounce), "fa-shake", e.shake), "fa-beat", e.beat), "fa-fade", e.fade), "fa-beat-fade", e.beatFade), "fa-flash", e.flash), re(re(t, "fa-spin-pulse", e.spinPulse), "fa-spin-reverse", e.spinReverse)); return Object.keys(n).map(function (r) { return n[r] ? r : null }).filter(function (r) { return r }) } function qt(e) { if (e && Ze(e) === "object" && e.prefix && e.iconName && e.icon) return e; if (fontawesomeSvgCore.parse.icon) return fontawesomeSvgCore.parse.icon(e); if (e === null) return null; if (Ze(e) === "object" && e.prefix && e.iconName) return e; if (Array.isArray(e) && e.length === 2) return { prefix: e[0], iconName: e[1] }; if (typeof e == "string") return { prefix: "fas", iconName: e } } var xi = vue.defineComponent({ name: "FontAwesomeIcon", props: { border: { type: Boolean, default: !1 }, fixedWidth: { type: Boolean, default: !1 }, flip: { type: [Boolean, String], default: !1, validator: function (t) { return [!0, !1, "horizontal", "vertical", "both"].indexOf(t) > -1 } }, icon: { type: [Object, Array, String], required: !0 }, mask: { type: [Object, Array, String], default: null }, maskId: { type: String, default: null }, listItem: { type: Boolean, default: !1 }, pull: { type: String, default: null, validator: function (t) { return ["right", "left"].indexOf(t) > -1 } }, pulse: { type: Boolean, default: !1 }, rotation: { type: [String, Number], default: null, validator: function (t) { return [90, 180, 270].indexOf(Number.parseInt(t, 10)) > -1 } }, swapOpacity: { type: Boolean, default: !1 }, size: { type: String, default: null, validator: function (t) { return ["2xs", "xs", "sm", "lg", "xl", "2xl", "1x", "2x", "3x", "4x", "5x", "6x", "7x", "8x", "9x", "10x"].indexOf(t) > -1 } }, spin: { type: Boolean, default: !1 }, transform: { type: [String, Object], default: null }, symbol: { type: [Boolean, String], default: !1 }, title: { type: String, default: null }, titleId: { type: String, default: null }, inverse: { type: Boolean, default: !1 }, bounce: { type: Boolean, default: !1 }, shake: { type: Boolean, default: !1 }, beat: { type: Boolean, default: !1 }, fade: { type: Boolean, default: !1 }, beatFade: { type: Boolean, default: !1 }, flash: { type: Boolean, default: !1 }, spinPulse: { type: Boolean, default: !1 }, spinReverse: { type: Boolean, default: !1 } }, setup: function (t, n) { var r = n.attrs, i = vue.computed(function () { return qt(t.icon) }), s = vue.computed(function () { return je("classes", Si(t)) }), a = vue.computed(function () { return je("transform", typeof t.transform == "string" ? fontawesomeSvgCore.parse.transform(t.transform) : t.transform) }), c = vue.computed(function () { return je("mask", qt(t.mask)) }), l = vue.computed(function () { return fontawesomeSvgCore.icon(i.value, de(de(de(de({}, s.value), a.value), c.value), {}, { symbol: t.symbol, title: t.title, titleId: t.titleId, maskId: t.maskId })) }); vue.watch(l, function (u) { if (!u) return wi("Could not find one or more icon(s)", i.value, c.value) }, { immediate: !0 }); var f = vue.computed(function () { return l.value ? Nt(l.value.abstract[0], {}, r) : null }); return function () { return f.value } } }); vue.defineComponent({ name: "FontAwesomeLayers", props: { fixedWidth: { type: Boolean, default: !1 } }, setup: function (t, n) { var r = n.slots, i = fontawesomeSvgCore.config.familyPrefix, s = vue.computed(function () { return ["".concat(i, "-layers")].concat(ht(t.fixedWidth ? ["".concat(i, "-fw")] : [])) }); return function () { return vue.h("div", { class: s.value }, r.default ? r.default() : []) } } }); vue.defineComponent({ name: "FontAwesomeLayersText", props: { value: { type: [String, Number], default: "" }, transform: { type: [String, Object], default: null }, counter: { type: Boolean, default: !1 }, position: { type: String, default: null, validator: function (t) { return ["bottom-left", "bottom-right", "top-left", "top-right"].indexOf(t) > -1 } } }, setup: function (t, n) { var r = n.attrs, i = fontawesomeSvgCore.config.familyPrefix, s = vue.computed(function () { return je("classes", [].concat(ht(t.counter ? ["".concat(i, "-layers-counter")] : []), ht(t.position ? ["".concat(i, "-layers-").concat(t.position)] : []))) }), a = vue.computed(function () { return je("transform", typeof t.transform == "string" ? fontawesomeSvgCore.parse.transform(t.transform) : t.transform) }), c = vue.computed(function () { var f = fontawesomeSvgCore.text(t.value.toString(), de(de({}, a.value), s.value)), u = f.abstract; return t.counter && (u[0].attributes.class = u[0].attributes.class.replace("fa-layers-text", "")), u[0] }), l = vue.computed(function () { return Nt(c.value, {}, r) }); return function () { return l.value } } }); const nt = pinia.defineStore("options", { state: () => ({ hasEpisodes: !0, sidebarVisible: !0, sidebarHeight: !1, searchVisible: !1 }), actions: { setHasEpisodes(e) { this.hasEpisodes = e; }, setSidebarVisible(e) { this.sidebarVisible = e; }, setSidebarHeight(e) { this.sidebarHeight = e; }, toggleSearchVisible() { this.searchVisible = !this.searchVisible; }, setSearchVisible(e) { this.searchVisible = e; } } }), Ii = ["title"], Ai = ["title"], Ci = vue.defineComponent({ __name: "ContentButtons", props: { isUiVisible: { type: Boolean } }, setup(e) { const t = nt(), { sidebarVisible: n, sidebarHeight: r } = pinia.storeToRefs(t), i = vue.computed(() => r.value ? freeSolidSvgIcons.faArrowUp : freeSolidSvgIcons.faArrowDown), s = vue.computed(() => n.value ? freeSolidSvgIcons.faArrowRight : freeSolidSvgIcons.faArrowLeft), a = vue.computed(() => r.value ? "Уменьшить по высоте" : "Увеличить по высоте"), c = vue.computed(() => n.value ? "Свернуть меню" : "Развернуть меню"); return (l, f) => { const u = vue.resolveComponent("fa-icon"); return vue.openBlock(), vue.createElementBlock("div", { class: vue.normalizeClass(["sp-viewport_buttons", "sp-buttons", "group", { visible: l.isUiVisible }]) }, [vue.createElementVNode("div", { class: "b-link_button is-icon size-lg", title: a.value, onClick: f[0] || (f[0] = y => vue.unref(t).setSidebarHeight(!vue.unref(r))) }, [vue.createVNode(u, { icon: i.value }, null, 8, ["icon"])], 8, Ii), vue.createElementVNode("div", { class: "b-link_button is-icon size-lg", title: c.value, onClick: f[1] || (f[1] = y => vue.unref(t).setSidebarVisible(!vue.unref(n))) }, [vue.createVNode(u, { icon: s.value }, null, 8, ["icon"])], 8, Ai)], 2) } } }); class Ie extends Error { constructor(n, r) { const i = `${Ie.extractMessage(n)}: ${JSON.stringify({ response: n, request: r })}`; super(i); ce(this, "response"); ce(this, "request"); Object.setPrototypeOf(this, Ie.prototype), this.response = n, this.request = r, typeof Error.captureStackTrace == "function" && Error.captureStackTrace(this, Ie); } static extractMessage(n) { var r, i; return ((i = (r = n.errors) == null ? void 0 : r[0]) == null ? void 0 : i.message) ?? `GraphQL Error (Code: ${String(n.status)})` } } const zt = e => e.toUpperCase(), lt = e => typeof e == "function" ? e() : e, mn = (e, t) => e.map((n, r) => [n, t[r]]), xe = e => { let t = {}; return e instanceof Headers ? t = Di(e) : Array.isArray(e) ? e.forEach(([n, r]) => { n && r !== void 0 && (t[n] = r); }) : e && (t = e), t }, Di = e => { const t = {}; return e.forEach((n, r) => { t[r] = n; }), t }, Li = e => { try { const t = e(); return Ri(t) ? t.catch(n => Gt(n)) : t } catch (t) { return Gt(t) } }, Gt = e => e instanceof Error ? e : new Error(String(e)), Ri = e => typeof e == "object" && e !== null && "then" in e && typeof e.then == "function" && "catch" in e && typeof e.catch == "function" && "finally" in e && typeof e.finally == "function", kt = e => { throw new Error(`Unhandled case: ${String(e)}`) }, We = e => typeof e == "object" && e !== null && !Array.isArray(e), Mi = (e, t) => e.documents ? e : { documents: e, requestHeaders: t, signal: void 0 }, Pi = (e, t, n) => e.query ? e : { query: e, variables: t, requestHeaders: n, signal: void 0 }; function Ye(e, t) { throw new Error(t) } function Fi(e) { return typeof e == "object" && e !== null } function Bi(e, t) { throw new Error("Unexpected invariant triggered.") } const ji = /\r\n|[\n\r]/g; function vt(e, t) { let n = 0, r = 1; for (const i of e.body.matchAll(ji)) { if (typeof i.index == "number" || Bi(), i.index >= t) break; n = i.index + i[0].length, r += 1; } return { line: r, column: t + 1 - n } } function $i(e) { return vn(e.source, vt(e.source, e.start)) } function vn(e, t) {
        const n = e.locationOffset.column - 1, r = "".padStart(n) + e.body, i = t.line - 1, s = e.locationOffset.line - 1, a = t.line + s, c = t.line === 1 ? n : 0, l = t.column + c, f = `${e.name}:${a}:${l}
`, u = r.split(/\r\n|[\n\r]/g), y = u[i]; if (y.length > 120) { const m = Math.floor(l / 80), I = l % 80, k = []; for (let D = 0; D < y.length; D += 80)k.push(y.slice(D, D + 80)); return f + Ht([[`${a} |`, k[0]], ...k.slice(1, m + 1).map(D => ["|", D]), ["|", "^".padStart(I)], ["|", k[m + 1]]]) } return f + Ht([[`${a - 1} |`, u[i - 1]], [`${a} |`, y], ["|", "^".padStart(l)], [`${a + 1} |`, u[i + 1]]])
    } function Ht(e) {
        const t = e.filter(([r, i]) => i !== void 0), n = Math.max(...t.map(([r]) => r.length)); return t.map(([r, i]) => r.padStart(n) + (i ? " " + i : "")).join(`
`)
    } function Ui(e) { const t = e[0]; return t == null || "kind" in t || "length" in t ? { nodes: t, source: e[1], positions: e[2], path: e[3], originalError: e[4], extensions: e[5] } : t } class Ot extends Error {
        constructor(t, ...n) { var r, i, s; const { nodes: a, source: c, positions: l, path: f, originalError: u, extensions: y } = Ui(n); super(t), this.name = "GraphQLError", this.path = f ?? void 0, this.originalError = u ?? void 0, this.nodes = Wt(Array.isArray(a) ? a : a ? [a] : void 0); const m = Wt((r = this.nodes) === null || r === void 0 ? void 0 : r.map(k => k.loc).filter(k => k != null)); this.source = c ?? (m == null || (i = m[0]) === null || i === void 0 ? void 0 : i.source), this.positions = l ?? (m == null ? void 0 : m.map(k => k.start)), this.locations = l && c ? l.map(k => vt(c, k)) : m == null ? void 0 : m.map(k => vt(k.source, k.start)); const I = Fi(u == null ? void 0 : u.extensions) ? u == null ? void 0 : u.extensions : void 0; this.extensions = (s = y ?? I) !== null && s !== void 0 ? s : Object.create(null), Object.defineProperties(this, { message: { writable: !0, enumerable: !0 }, name: { enumerable: !1 }, nodes: { enumerable: !1 }, source: { enumerable: !1 }, positions: { enumerable: !1 }, originalError: { enumerable: !1 } }), u != null && u.stack ? Object.defineProperty(this, "stack", { value: u.stack, writable: !0, configurable: !0 }) : Error.captureStackTrace ? Error.captureStackTrace(this, Ot) : Object.defineProperty(this, "stack", { value: Error().stack, writable: !0, configurable: !0 }); } get [Symbol.toStringTag]() { return "GraphQLError" } toString() {
            let t = this.message; if (this.nodes) for (const n of this.nodes) n.loc && (t += `

`+ $i(n.loc)); else if (this.source && this.locations) for (const n of this.locations) t += `

`+ vn(this.source, n); return t
        } toJSON() { const t = { message: this.message }; return this.locations != null && (t.locations = this.locations), this.path != null && (t.path = this.path), this.extensions != null && Object.keys(this.extensions).length > 0 && (t.extensions = this.extensions), t }
    } function Wt(e) { return e === void 0 || e.length === 0 ? void 0 : e } function ee(e, t, n) { return new Ot(`Syntax Error: ${n}`, { source: e, positions: [t] }) } class Vi { constructor(t, n, r) { this.start = t.start, this.end = n.end, this.startToken = t, this.endToken = n, this.source = r; } get [Symbol.toStringTag]() { return "Location" } toJSON() { return { start: this.start, end: this.end } } } class yn { constructor(t, n, r, i, s, a) { this.kind = t, this.start = n, this.end = r, this.line = i, this.column = s, this.value = a, this.prev = null, this.next = null; } get [Symbol.toStringTag]() { return "Token" } toJSON() { return { kind: this.kind, value: this.value, line: this.line, column: this.column } } } const _n = { Name: [], Document: ["definitions"], OperationDefinition: ["name", "variableDefinitions", "directives", "selectionSet"], VariableDefinition: ["variable", "type", "defaultValue", "directives"], Variable: ["name"], SelectionSet: ["selections"], Field: ["alias", "name", "arguments", "directives", "selectionSet"], Argument: ["name", "value"], FragmentSpread: ["name", "directives"], InlineFragment: ["typeCondition", "directives", "selectionSet"], FragmentDefinition: ["name", "variableDefinitions", "typeCondition", "directives", "selectionSet"], IntValue: [], FloatValue: [], StringValue: [], BooleanValue: [], NullValue: [], EnumValue: [], ListValue: ["values"], ObjectValue: ["fields"], ObjectField: ["name", "value"], Directive: ["name", "arguments"], NamedType: ["name"], ListType: ["type"], NonNullType: ["type"], SchemaDefinition: ["description", "directives", "operationTypes"], OperationTypeDefinition: ["type"], ScalarTypeDefinition: ["description", "name", "directives"], ObjectTypeDefinition: ["description", "name", "interfaces", "directives", "fields"], FieldDefinition: ["description", "name", "arguments", "type", "directives"], InputValueDefinition: ["description", "name", "type", "defaultValue", "directives"], InterfaceTypeDefinition: ["description", "name", "interfaces", "directives", "fields"], UnionTypeDefinition: ["description", "name", "directives", "types"], EnumTypeDefinition: ["description", "name", "directives", "values"], EnumValueDefinition: ["description", "name", "directives"], InputObjectTypeDefinition: ["description", "name", "directives", "fields"], DirectiveDefinition: ["description", "name", "arguments", "locations"], SchemaExtension: ["directives", "operationTypes"], ScalarTypeExtension: ["name", "directives"], ObjectTypeExtension: ["name", "interfaces", "directives", "fields"], InterfaceTypeExtension: ["name", "interfaces", "directives", "fields"], UnionTypeExtension: ["name", "directives", "types"], EnumTypeExtension: ["name", "directives", "values"], InputObjectTypeExtension: ["name", "directives", "fields"] }, qi = new Set(Object.keys(_n)); function Yt(e) { const t = e == null ? void 0 : e.kind; return typeof t == "string" && qi.has(t) } var be; (function (e) { e.QUERY = "query", e.MUTATION = "mutation", e.SUBSCRIPTION = "subscription"; })(be || (be = {})); var yt; (function (e) { e.QUERY = "QUERY", e.MUTATION = "MUTATION", e.SUBSCRIPTION = "SUBSCRIPTION", e.FIELD = "FIELD", e.FRAGMENT_DEFINITION = "FRAGMENT_DEFINITION", e.FRAGMENT_SPREAD = "FRAGMENT_SPREAD", e.INLINE_FRAGMENT = "INLINE_FRAGMENT", e.VARIABLE_DEFINITION = "VARIABLE_DEFINITION", e.SCHEMA = "SCHEMA", e.SCALAR = "SCALAR", e.OBJECT = "OBJECT", e.FIELD_DEFINITION = "FIELD_DEFINITION", e.ARGUMENT_DEFINITION = "ARGUMENT_DEFINITION", e.INTERFACE = "INTERFACE", e.UNION = "UNION", e.ENUM = "ENUM", e.ENUM_VALUE = "ENUM_VALUE", e.INPUT_OBJECT = "INPUT_OBJECT", e.INPUT_FIELD_DEFINITION = "INPUT_FIELD_DEFINITION"; })(yt || (yt = {})); var x; (function (e) { e.NAME = "Name", e.DOCUMENT = "Document", e.OPERATION_DEFINITION = "OperationDefinition", e.VARIABLE_DEFINITION = "VariableDefinition", e.SELECTION_SET = "SelectionSet", e.FIELD = "Field", e.ARGUMENT = "Argument", e.FRAGMENT_SPREAD = "FragmentSpread", e.INLINE_FRAGMENT = "InlineFragment", e.FRAGMENT_DEFINITION = "FragmentDefinition", e.VARIABLE = "Variable", e.INT = "IntValue", e.FLOAT = "FloatValue", e.STRING = "StringValue", e.BOOLEAN = "BooleanValue", e.NULL = "NullValue", e.ENUM = "EnumValue", e.LIST = "ListValue", e.OBJECT = "ObjectValue", e.OBJECT_FIELD = "ObjectField", e.DIRECTIVE = "Directive", e.NAMED_TYPE = "NamedType", e.LIST_TYPE = "ListType", e.NON_NULL_TYPE = "NonNullType", e.SCHEMA_DEFINITION = "SchemaDefinition", e.OPERATION_TYPE_DEFINITION = "OperationTypeDefinition", e.SCALAR_TYPE_DEFINITION = "ScalarTypeDefinition", e.OBJECT_TYPE_DEFINITION = "ObjectTypeDefinition", e.FIELD_DEFINITION = "FieldDefinition", e.INPUT_VALUE_DEFINITION = "InputValueDefinition", e.INTERFACE_TYPE_DEFINITION = "InterfaceTypeDefinition", e.UNION_TYPE_DEFINITION = "UnionTypeDefinition", e.ENUM_TYPE_DEFINITION = "EnumTypeDefinition", e.ENUM_VALUE_DEFINITION = "EnumValueDefinition", e.INPUT_OBJECT_TYPE_DEFINITION = "InputObjectTypeDefinition", e.DIRECTIVE_DEFINITION = "DirectiveDefinition", e.SCHEMA_EXTENSION = "SchemaExtension", e.SCALAR_TYPE_EXTENSION = "ScalarTypeExtension", e.OBJECT_TYPE_EXTENSION = "ObjectTypeExtension", e.INTERFACE_TYPE_EXTENSION = "InterfaceTypeExtension", e.UNION_TYPE_EXTENSION = "UnionTypeExtension", e.ENUM_TYPE_EXTENSION = "EnumTypeExtension", e.INPUT_OBJECT_TYPE_EXTENSION = "InputObjectTypeExtension"; })(x || (x = {})); function _t(e) { return e === 9 || e === 32 } function Ue(e) { return e >= 48 && e <= 57 } function En(e) { return e >= 97 && e <= 122 || e >= 65 && e <= 90 } function gn(e) { return En(e) || e === 95 } function zi(e) { return En(e) || Ue(e) || e === 95 } function Gi(e) { var t; let n = Number.MAX_SAFE_INTEGER, r = null, i = -1; for (let a = 0; a < e.length; ++a) { var s; const c = e[a], l = Hi(c); l !== c.length && (r = (s = r) !== null && s !== void 0 ? s : a, i = a, a !== 0 && l < n && (n = l)); } return e.map((a, c) => c === 0 ? a : a.slice(n)).slice((t = r) !== null && t !== void 0 ? t : 0, i + 1) } function Hi(e) { let t = 0; for (; t < e.length && _t(e.charCodeAt(t));)++t; return t } function Wi(e, t) {
        const n = e.replace(/"""/g, '\\"""'), r = n.split(/\r\n|[\n\r]/g), i = r.length === 1, s = r.length > 1 && r.slice(1).every(I => I.length === 0 || _t(I.charCodeAt(0))), a = n.endsWith('\\"""'), c = e.endsWith('"') && !a, l = e.endsWith("\\"), f = c || l, u = !i || e.length > 70 || f || s || a; let y = ""; const m = i && _t(e.charCodeAt(0)); return (u && !m || s) && (y += `
`), y += n, (u || f) && (y += `
`), '"""' + y + '"""'
    } var h; (function (e) { e.SOF = "<SOF>", e.EOF = "<EOF>", e.BANG = "!", e.DOLLAR = "$", e.AMP = "&", e.PAREN_L = "(", e.PAREN_R = ")", e.SPREAD = "...", e.COLON = ":", e.EQUALS = "=", e.AT = "@", e.BRACKET_L = "[", e.BRACKET_R = "]", e.BRACE_L = "{", e.PIPE = "|", e.BRACE_R = "}", e.NAME = "Name", e.INT = "Int", e.FLOAT = "Float", e.STRING = "String", e.BLOCK_STRING = "BlockString", e.COMMENT = "Comment"; })(h || (h = {})); class Yi { constructor(t) { const n = new yn(h.SOF, 0, 0, 0, 0); this.source = t, this.lastToken = n, this.token = n, this.line = 1, this.lineStart = 0; } get [Symbol.toStringTag]() { return "Lexer" } advance() { return this.lastToken = this.token, this.token = this.lookahead() } lookahead() { let t = this.token; if (t.kind !== h.EOF) do if (t.next) t = t.next; else { const n = Qi(this, t.end); t.next = n, n.prev = t, t = n; } while (t.kind === h.COMMENT); return t } } function Ji(e) { return e === h.BANG || e === h.DOLLAR || e === h.AMP || e === h.PAREN_L || e === h.PAREN_R || e === h.SPREAD || e === h.COLON || e === h.EQUALS || e === h.AT || e === h.BRACKET_L || e === h.BRACKET_R || e === h.BRACE_L || e === h.PIPE || e === h.BRACE_R } function Le(e) { return e >= 0 && e <= 55295 || e >= 57344 && e <= 1114111 } function it(e, t) { return bn(e.charCodeAt(t)) && Tn(e.charCodeAt(t + 1)) } function bn(e) { return e >= 55296 && e <= 56319 } function Tn(e) { return e >= 56320 && e <= 57343 } function Ne(e, t) { const n = e.source.body.codePointAt(t); if (n === void 0) return h.EOF; if (n >= 32 && n <= 126) { const r = String.fromCodePoint(n); return r === '"' ? `'"'` : `"${r}"` } return "U+" + n.toString(16).toUpperCase().padStart(4, "0") } function J(e, t, n, r, i) { const s = e.line, a = 1 + n - e.lineStart; return new yn(t, n, r, s, a, i) } function Qi(e, t) { const n = e.source.body, r = n.length; let i = t; for (; i < r;) { const s = n.charCodeAt(i); switch (s) { case 65279: case 9: case 32: case 44: ++i; continue; case 10: ++i, ++e.line, e.lineStart = i; continue; case 13: n.charCodeAt(i + 1) === 10 ? i += 2 : ++i, ++e.line, e.lineStart = i; continue; case 35: return Xi(e, i); case 33: return J(e, h.BANG, i, i + 1); case 36: return J(e, h.DOLLAR, i, i + 1); case 38: return J(e, h.AMP, i, i + 1); case 40: return J(e, h.PAREN_L, i, i + 1); case 41: return J(e, h.PAREN_R, i, i + 1); case 46: if (n.charCodeAt(i + 1) === 46 && n.charCodeAt(i + 2) === 46) return J(e, h.SPREAD, i, i + 3); break; case 58: return J(e, h.COLON, i, i + 1); case 61: return J(e, h.EQUALS, i, i + 1); case 64: return J(e, h.AT, i, i + 1); case 91: return J(e, h.BRACKET_L, i, i + 1); case 93: return J(e, h.BRACKET_R, i, i + 1); case 123: return J(e, h.BRACE_L, i, i + 1); case 124: return J(e, h.PIPE, i, i + 1); case 125: return J(e, h.BRACE_R, i, i + 1); case 34: return n.charCodeAt(i + 1) === 34 && n.charCodeAt(i + 2) === 34 ? ir(e, i) : Ki(e, i) }if (Ue(s) || s === 45) return Zi(e, i, s); if (gn(s)) return rr(e, i); throw ee(e.source, i, s === 39 ? `Unexpected single quote character ('), did you mean to use a double quote (")?` : Le(s) || it(n, i) ? `Unexpected character: ${Ne(e, i)}.` : `Invalid character: ${Ne(e, i)}.`) } return J(e, h.EOF, r, r) } function Xi(e, t) { const n = e.source.body, r = n.length; let i = t + 1; for (; i < r;) { const s = n.charCodeAt(i); if (s === 10 || s === 13) break; if (Le(s)) ++i; else if (it(n, i)) i += 2; else break } return J(e, h.COMMENT, t, i, n.slice(t + 1, i)) } function Zi(e, t, n) { const r = e.source.body; let i = t, s = n, a = !1; if (s === 45 && (s = r.charCodeAt(++i)), s === 48) { if (s = r.charCodeAt(++i), Ue(s)) throw ee(e.source, i, `Invalid number, unexpected digit after 0: ${Ne(e, i)}.`) } else i = ct(e, i, s), s = r.charCodeAt(i); if (s === 46 && (a = !0, s = r.charCodeAt(++i), i = ct(e, i, s), s = r.charCodeAt(i)), (s === 69 || s === 101) && (a = !0, s = r.charCodeAt(++i), (s === 43 || s === 45) && (s = r.charCodeAt(++i)), i = ct(e, i, s), s = r.charCodeAt(i)), s === 46 || gn(s)) throw ee(e.source, i, `Invalid number, expected digit but got: ${Ne(e, i)}.`); return J(e, a ? h.FLOAT : h.INT, t, i, r.slice(t, i)) } function ct(e, t, n) { if (!Ue(n)) throw ee(e.source, t, `Invalid number, expected digit but got: ${Ne(e, t)}.`); const r = e.source.body; let i = t + 1; for (; Ue(r.charCodeAt(i));)++i; return i } function Ki(e, t) { const n = e.source.body, r = n.length; let i = t + 1, s = i, a = ""; for (; i < r;) { const c = n.charCodeAt(i); if (c === 34) return a += n.slice(s, i), J(e, h.STRING, t, i + 1, a); if (c === 92) { a += n.slice(s, i); const l = n.charCodeAt(i + 1) === 117 ? n.charCodeAt(i + 2) === 123 ? er(e, i) : tr(e, i) : nr(e, i); a += l.value, i += l.size, s = i; continue } if (c === 10 || c === 13) break; if (Le(c)) ++i; else if (it(n, i)) i += 2; else throw ee(e.source, i, `Invalid character within String: ${Ne(e, i)}.`) } throw ee(e.source, i, "Unterminated string.") } function er(e, t) { const n = e.source.body; let r = 0, i = 3; for (; i < 12;) { const s = n.charCodeAt(t + i++); if (s === 125) { if (i < 5 || !Le(r)) break; return { value: String.fromCodePoint(r), size: i } } if (r = r << 4 | Be(s), r < 0) break } throw ee(e.source, t, `Invalid Unicode escape sequence: "${n.slice(t, t + i)}".`) } function tr(e, t) { const n = e.source.body, r = Jt(n, t + 2); if (Le(r)) return { value: String.fromCodePoint(r), size: 6 }; if (bn(r) && n.charCodeAt(t + 6) === 92 && n.charCodeAt(t + 7) === 117) { const i = Jt(n, t + 8); if (Tn(i)) return { value: String.fromCodePoint(r, i), size: 12 } } throw ee(e.source, t, `Invalid Unicode escape sequence: "${n.slice(t, t + 6)}".`) } function Jt(e, t) { return Be(e.charCodeAt(t)) << 12 | Be(e.charCodeAt(t + 1)) << 8 | Be(e.charCodeAt(t + 2)) << 4 | Be(e.charCodeAt(t + 3)) } function Be(e) { return e >= 48 && e <= 57 ? e - 48 : e >= 65 && e <= 70 ? e - 55 : e >= 97 && e <= 102 ? e - 87 : -1 } function nr(e, t) {
        const n = e.source.body; switch (n.charCodeAt(t + 1)) {
            case 34: return { value: '"', size: 2 }; case 92: return { value: "\\", size: 2 }; case 47: return { value: "/", size: 2 }; case 98: return { value: "\b", size: 2 }; case 102: return { value: "\f", size: 2 }; case 110: return {
                value: `
`, size: 2
            }; case 114: return { value: "\r", size: 2 }; case 116: return { value: "	", size: 2 }
        }throw ee(e.source, t, `Invalid character escape sequence: "${n.slice(t, t + 2)}".`)
    } function ir(e, t) {
        const n = e.source.body, r = n.length; let i = e.lineStart, s = t + 3, a = s, c = ""; const l = []; for (; s < r;) {
            const f = n.charCodeAt(s); if (f === 34 && n.charCodeAt(s + 1) === 34 && n.charCodeAt(s + 2) === 34) {
                c += n.slice(a, s), l.push(c); const u = J(e, h.BLOCK_STRING, t, s + 3, Gi(l).join(`
`)); return e.line += l.length - 1, e.lineStart = i, u
            } if (f === 92 && n.charCodeAt(s + 1) === 34 && n.charCodeAt(s + 2) === 34 && n.charCodeAt(s + 3) === 34) { c += n.slice(a, s), a = s + 1, s += 4; continue } if (f === 10 || f === 13) { c += n.slice(a, s), l.push(c), f === 13 && n.charCodeAt(s + 1) === 10 ? s += 2 : ++s, c = "", a = s, i = s; continue } if (Le(f)) ++s; else if (it(n, s)) s += 2; else throw ee(e.source, s, `Invalid character within String: ${Ne(e, s)}.`)
        } throw ee(e.source, s, "Unterminated string.")
    } function rr(e, t) { const n = e.source.body, r = n.length; let i = t + 1; for (; i < r;) { const s = n.charCodeAt(i); if (zi(s)) ++i; else break } return J(e, h.NAME, t, i, n.slice(t, i)) } const sr = 10, Nn = 2; function wt(e) { return rt(e, []) } function rt(e, t) { switch (typeof e) { case "string": return JSON.stringify(e); case "function": return e.name ? `[function ${e.name}]` : "[function]"; case "object": return ar(e, t); default: return String(e) } } function ar(e, t) { if (e === null) return "null"; if (t.includes(e)) return "[Circular]"; const n = [...t, e]; if (or(e)) { const r = e.toJSON(); if (r !== e) return typeof r == "string" ? r : rt(r, n) } else if (Array.isArray(e)) return cr(e, n); return lr(e, n) } function or(e) { return typeof e.toJSON == "function" } function lr(e, t) { const n = Object.entries(e); return n.length === 0 ? "{}" : t.length > Nn ? "[" + ur(e) + "]" : "{ " + n.map(([i, s]) => i + ": " + rt(s, t)).join(", ") + " }" } function cr(e, t) { if (e.length === 0) return "[]"; if (t.length > Nn) return "[Array]"; const n = Math.min(sr, e.length), r = e.length - n, i = []; for (let s = 0; s < n; ++s)i.push(rt(e[s], t)); return r === 1 ? i.push("... 1 more item") : r > 1 && i.push(`... ${r} more items`), "[" + i.join(", ") + "]" } function ur(e) { const t = Object.prototype.toString.call(e).replace(/^\[object /, "").replace(/]$/, ""); if (t === "Object" && typeof e.constructor == "function") { const n = e.constructor.name; if (typeof n == "string" && n !== "") return n } return t } const dr = globalThis.process && !0, fr = dr ? function (t, n) { return t instanceof n } : function (t, n) {
        if (t instanceof n) return !0; if (typeof t == "object" && t !== null) {
            var r; const i = n.prototype[Symbol.toStringTag], s = Symbol.toStringTag in t ? t[Symbol.toStringTag] : (r = t.constructor) === null || r === void 0 ? void 0 : r.name; if (i === s) {
                const a = wt(t); throw new Error(`Cannot use ${i} "${a}" from another module or realm.

Ensure that there is only one instance of "graphql" in the node_modules
directory. If different versions of "graphql" are the dependencies of other
relied on modules, use "resolutions" to ensure only one version is installed.

https://yarnpkg.com/en/docs/selective-version-resolutions

Duplicate "graphql" modules cannot be used at the same time since different
versions may have different capabilities and behavior. The data from one
version used in the function from another could produce confusing and
spurious results.`)
            }
        } return !1
    }; class kn { constructor(t, n = "GraphQL request", r = { line: 1, column: 1 }) { typeof t == "string" || Ye(!1, `Body must be a string. Received: ${wt(t)}.`), this.body = t, this.name = n, this.locationOffset = r, this.locationOffset.line > 0 || Ye(!1, "line in locationOffset is 1-indexed and must be positive."), this.locationOffset.column > 0 || Ye(!1, "column in locationOffset is 1-indexed and must be positive."); } get [Symbol.toStringTag]() { return "Source" } } function pr(e) { return fr(e, kn) } function hr(e, t) { return new mr(e, t).parseDocument() } class mr { constructor(t, n = {}) { const r = pr(t) ? t : new kn(t); this._lexer = new Yi(r), this._options = n, this._tokenCounter = 0; } parseName() { const t = this.expectToken(h.NAME); return this.node(t, { kind: x.NAME, value: t.value }) } parseDocument() { return this.node(this._lexer.token, { kind: x.DOCUMENT, definitions: this.many(h.SOF, this.parseDefinition, h.EOF) }) } parseDefinition() { if (this.peek(h.BRACE_L)) return this.parseOperationDefinition(); const t = this.peekDescription(), n = t ? this._lexer.lookahead() : this._lexer.token; if (n.kind === h.NAME) { switch (n.value) { case "schema": return this.parseSchemaDefinition(); case "scalar": return this.parseScalarTypeDefinition(); case "type": return this.parseObjectTypeDefinition(); case "interface": return this.parseInterfaceTypeDefinition(); case "union": return this.parseUnionTypeDefinition(); case "enum": return this.parseEnumTypeDefinition(); case "input": return this.parseInputObjectTypeDefinition(); case "directive": return this.parseDirectiveDefinition() }if (t) throw ee(this._lexer.source, this._lexer.token.start, "Unexpected description, descriptions are supported only on type definitions."); switch (n.value) { case "query": case "mutation": case "subscription": return this.parseOperationDefinition(); case "fragment": return this.parseFragmentDefinition(); case "extend": return this.parseTypeSystemExtension() } } throw this.unexpected(n) } parseOperationDefinition() { const t = this._lexer.token; if (this.peek(h.BRACE_L)) return this.node(t, { kind: x.OPERATION_DEFINITION, operation: be.QUERY, name: void 0, variableDefinitions: [], directives: [], selectionSet: this.parseSelectionSet() }); const n = this.parseOperationType(); let r; return this.peek(h.NAME) && (r = this.parseName()), this.node(t, { kind: x.OPERATION_DEFINITION, operation: n, name: r, variableDefinitions: this.parseVariableDefinitions(), directives: this.parseDirectives(!1), selectionSet: this.parseSelectionSet() }) } parseOperationType() { const t = this.expectToken(h.NAME); switch (t.value) { case "query": return be.QUERY; case "mutation": return be.MUTATION; case "subscription": return be.SUBSCRIPTION }throw this.unexpected(t) } parseVariableDefinitions() { return this.optionalMany(h.PAREN_L, this.parseVariableDefinition, h.PAREN_R) } parseVariableDefinition() { return this.node(this._lexer.token, { kind: x.VARIABLE_DEFINITION, variable: this.parseVariable(), type: (this.expectToken(h.COLON), this.parseTypeReference()), defaultValue: this.expectOptionalToken(h.EQUALS) ? this.parseConstValueLiteral() : void 0, directives: this.parseConstDirectives() }) } parseVariable() { const t = this._lexer.token; return this.expectToken(h.DOLLAR), this.node(t, { kind: x.VARIABLE, name: this.parseName() }) } parseSelectionSet() { return this.node(this._lexer.token, { kind: x.SELECTION_SET, selections: this.many(h.BRACE_L, this.parseSelection, h.BRACE_R) }) } parseSelection() { return this.peek(h.SPREAD) ? this.parseFragment() : this.parseField() } parseField() { const t = this._lexer.token, n = this.parseName(); let r, i; return this.expectOptionalToken(h.COLON) ? (r = n, i = this.parseName()) : i = n, this.node(t, { kind: x.FIELD, alias: r, name: i, arguments: this.parseArguments(!1), directives: this.parseDirectives(!1), selectionSet: this.peek(h.BRACE_L) ? this.parseSelectionSet() : void 0 }) } parseArguments(t) { const n = t ? this.parseConstArgument : this.parseArgument; return this.optionalMany(h.PAREN_L, n, h.PAREN_R) } parseArgument(t = !1) { const n = this._lexer.token, r = this.parseName(); return this.expectToken(h.COLON), this.node(n, { kind: x.ARGUMENT, name: r, value: this.parseValueLiteral(t) }) } parseConstArgument() { return this.parseArgument(!0) } parseFragment() { const t = this._lexer.token; this.expectToken(h.SPREAD); const n = this.expectOptionalKeyword("on"); return !n && this.peek(h.NAME) ? this.node(t, { kind: x.FRAGMENT_SPREAD, name: this.parseFragmentName(), directives: this.parseDirectives(!1) }) : this.node(t, { kind: x.INLINE_FRAGMENT, typeCondition: n ? this.parseNamedType() : void 0, directives: this.parseDirectives(!1), selectionSet: this.parseSelectionSet() }) } parseFragmentDefinition() { const t = this._lexer.token; return this.expectKeyword("fragment"), this._options.allowLegacyFragmentVariables === !0 ? this.node(t, { kind: x.FRAGMENT_DEFINITION, name: this.parseFragmentName(), variableDefinitions: this.parseVariableDefinitions(), typeCondition: (this.expectKeyword("on"), this.parseNamedType()), directives: this.parseDirectives(!1), selectionSet: this.parseSelectionSet() }) : this.node(t, { kind: x.FRAGMENT_DEFINITION, name: this.parseFragmentName(), typeCondition: (this.expectKeyword("on"), this.parseNamedType()), directives: this.parseDirectives(!1), selectionSet: this.parseSelectionSet() }) } parseFragmentName() { if (this._lexer.token.value === "on") throw this.unexpected(); return this.parseName() } parseValueLiteral(t) { const n = this._lexer.token; switch (n.kind) { case h.BRACKET_L: return this.parseList(t); case h.BRACE_L: return this.parseObject(t); case h.INT: return this.advanceLexer(), this.node(n, { kind: x.INT, value: n.value }); case h.FLOAT: return this.advanceLexer(), this.node(n, { kind: x.FLOAT, value: n.value }); case h.STRING: case h.BLOCK_STRING: return this.parseStringLiteral(); case h.NAME: switch (this.advanceLexer(), n.value) { case "true": return this.node(n, { kind: x.BOOLEAN, value: !0 }); case "false": return this.node(n, { kind: x.BOOLEAN, value: !1 }); case "null": return this.node(n, { kind: x.NULL }); default: return this.node(n, { kind: x.ENUM, value: n.value }) }case h.DOLLAR: if (t) if (this.expectToken(h.DOLLAR), this._lexer.token.kind === h.NAME) { const r = this._lexer.token.value; throw ee(this._lexer.source, n.start, `Unexpected variable "$${r}" in constant value.`) } else throw this.unexpected(n); return this.parseVariable(); default: throw this.unexpected() } } parseConstValueLiteral() { return this.parseValueLiteral(!0) } parseStringLiteral() { const t = this._lexer.token; return this.advanceLexer(), this.node(t, { kind: x.STRING, value: t.value, block: t.kind === h.BLOCK_STRING }) } parseList(t) { const n = () => this.parseValueLiteral(t); return this.node(this._lexer.token, { kind: x.LIST, values: this.any(h.BRACKET_L, n, h.BRACKET_R) }) } parseObject(t) { const n = () => this.parseObjectField(t); return this.node(this._lexer.token, { kind: x.OBJECT, fields: this.any(h.BRACE_L, n, h.BRACE_R) }) } parseObjectField(t) { const n = this._lexer.token, r = this.parseName(); return this.expectToken(h.COLON), this.node(n, { kind: x.OBJECT_FIELD, name: r, value: this.parseValueLiteral(t) }) } parseDirectives(t) { const n = []; for (; this.peek(h.AT);)n.push(this.parseDirective(t)); return n } parseConstDirectives() { return this.parseDirectives(!0) } parseDirective(t) { const n = this._lexer.token; return this.expectToken(h.AT), this.node(n, { kind: x.DIRECTIVE, name: this.parseName(), arguments: this.parseArguments(t) }) } parseTypeReference() { const t = this._lexer.token; let n; if (this.expectOptionalToken(h.BRACKET_L)) { const r = this.parseTypeReference(); this.expectToken(h.BRACKET_R), n = this.node(t, { kind: x.LIST_TYPE, type: r }); } else n = this.parseNamedType(); return this.expectOptionalToken(h.BANG) ? this.node(t, { kind: x.NON_NULL_TYPE, type: n }) : n } parseNamedType() { return this.node(this._lexer.token, { kind: x.NAMED_TYPE, name: this.parseName() }) } peekDescription() { return this.peek(h.STRING) || this.peek(h.BLOCK_STRING) } parseDescription() { if (this.peekDescription()) return this.parseStringLiteral() } parseSchemaDefinition() { const t = this._lexer.token, n = this.parseDescription(); this.expectKeyword("schema"); const r = this.parseConstDirectives(), i = this.many(h.BRACE_L, this.parseOperationTypeDefinition, h.BRACE_R); return this.node(t, { kind: x.SCHEMA_DEFINITION, description: n, directives: r, operationTypes: i }) } parseOperationTypeDefinition() { const t = this._lexer.token, n = this.parseOperationType(); this.expectToken(h.COLON); const r = this.parseNamedType(); return this.node(t, { kind: x.OPERATION_TYPE_DEFINITION, operation: n, type: r }) } parseScalarTypeDefinition() { const t = this._lexer.token, n = this.parseDescription(); this.expectKeyword("scalar"); const r = this.parseName(), i = this.parseConstDirectives(); return this.node(t, { kind: x.SCALAR_TYPE_DEFINITION, description: n, name: r, directives: i }) } parseObjectTypeDefinition() { const t = this._lexer.token, n = this.parseDescription(); this.expectKeyword("type"); const r = this.parseName(), i = this.parseImplementsInterfaces(), s = this.parseConstDirectives(), a = this.parseFieldsDefinition(); return this.node(t, { kind: x.OBJECT_TYPE_DEFINITION, description: n, name: r, interfaces: i, directives: s, fields: a }) } parseImplementsInterfaces() { return this.expectOptionalKeyword("implements") ? this.delimitedMany(h.AMP, this.parseNamedType) : [] } parseFieldsDefinition() { return this.optionalMany(h.BRACE_L, this.parseFieldDefinition, h.BRACE_R) } parseFieldDefinition() { const t = this._lexer.token, n = this.parseDescription(), r = this.parseName(), i = this.parseArgumentDefs(); this.expectToken(h.COLON); const s = this.parseTypeReference(), a = this.parseConstDirectives(); return this.node(t, { kind: x.FIELD_DEFINITION, description: n, name: r, arguments: i, type: s, directives: a }) } parseArgumentDefs() { return this.optionalMany(h.PAREN_L, this.parseInputValueDef, h.PAREN_R) } parseInputValueDef() { const t = this._lexer.token, n = this.parseDescription(), r = this.parseName(); this.expectToken(h.COLON); const i = this.parseTypeReference(); let s; this.expectOptionalToken(h.EQUALS) && (s = this.parseConstValueLiteral()); const a = this.parseConstDirectives(); return this.node(t, { kind: x.INPUT_VALUE_DEFINITION, description: n, name: r, type: i, defaultValue: s, directives: a }) } parseInterfaceTypeDefinition() { const t = this._lexer.token, n = this.parseDescription(); this.expectKeyword("interface"); const r = this.parseName(), i = this.parseImplementsInterfaces(), s = this.parseConstDirectives(), a = this.parseFieldsDefinition(); return this.node(t, { kind: x.INTERFACE_TYPE_DEFINITION, description: n, name: r, interfaces: i, directives: s, fields: a }) } parseUnionTypeDefinition() { const t = this._lexer.token, n = this.parseDescription(); this.expectKeyword("union"); const r = this.parseName(), i = this.parseConstDirectives(), s = this.parseUnionMemberTypes(); return this.node(t, { kind: x.UNION_TYPE_DEFINITION, description: n, name: r, directives: i, types: s }) } parseUnionMemberTypes() { return this.expectOptionalToken(h.EQUALS) ? this.delimitedMany(h.PIPE, this.parseNamedType) : [] } parseEnumTypeDefinition() { const t = this._lexer.token, n = this.parseDescription(); this.expectKeyword("enum"); const r = this.parseName(), i = this.parseConstDirectives(), s = this.parseEnumValuesDefinition(); return this.node(t, { kind: x.ENUM_TYPE_DEFINITION, description: n, name: r, directives: i, values: s }) } parseEnumValuesDefinition() { return this.optionalMany(h.BRACE_L, this.parseEnumValueDefinition, h.BRACE_R) } parseEnumValueDefinition() { const t = this._lexer.token, n = this.parseDescription(), r = this.parseEnumValueName(), i = this.parseConstDirectives(); return this.node(t, { kind: x.ENUM_VALUE_DEFINITION, description: n, name: r, directives: i }) } parseEnumValueName() { if (this._lexer.token.value === "true" || this._lexer.token.value === "false" || this._lexer.token.value === "null") throw ee(this._lexer.source, this._lexer.token.start, `${He(this._lexer.token)} is reserved and cannot be used for an enum value.`); return this.parseName() } parseInputObjectTypeDefinition() { const t = this._lexer.token, n = this.parseDescription(); this.expectKeyword("input"); const r = this.parseName(), i = this.parseConstDirectives(), s = this.parseInputFieldsDefinition(); return this.node(t, { kind: x.INPUT_OBJECT_TYPE_DEFINITION, description: n, name: r, directives: i, fields: s }) } parseInputFieldsDefinition() { return this.optionalMany(h.BRACE_L, this.parseInputValueDef, h.BRACE_R) } parseTypeSystemExtension() { const t = this._lexer.lookahead(); if (t.kind === h.NAME) switch (t.value) { case "schema": return this.parseSchemaExtension(); case "scalar": return this.parseScalarTypeExtension(); case "type": return this.parseObjectTypeExtension(); case "interface": return this.parseInterfaceTypeExtension(); case "union": return this.parseUnionTypeExtension(); case "enum": return this.parseEnumTypeExtension(); case "input": return this.parseInputObjectTypeExtension() }throw this.unexpected(t) } parseSchemaExtension() { const t = this._lexer.token; this.expectKeyword("extend"), this.expectKeyword("schema"); const n = this.parseConstDirectives(), r = this.optionalMany(h.BRACE_L, this.parseOperationTypeDefinition, h.BRACE_R); if (n.length === 0 && r.length === 0) throw this.unexpected(); return this.node(t, { kind: x.SCHEMA_EXTENSION, directives: n, operationTypes: r }) } parseScalarTypeExtension() { const t = this._lexer.token; this.expectKeyword("extend"), this.expectKeyword("scalar"); const n = this.parseName(), r = this.parseConstDirectives(); if (r.length === 0) throw this.unexpected(); return this.node(t, { kind: x.SCALAR_TYPE_EXTENSION, name: n, directives: r }) } parseObjectTypeExtension() { const t = this._lexer.token; this.expectKeyword("extend"), this.expectKeyword("type"); const n = this.parseName(), r = this.parseImplementsInterfaces(), i = this.parseConstDirectives(), s = this.parseFieldsDefinition(); if (r.length === 0 && i.length === 0 && s.length === 0) throw this.unexpected(); return this.node(t, { kind: x.OBJECT_TYPE_EXTENSION, name: n, interfaces: r, directives: i, fields: s }) } parseInterfaceTypeExtension() { const t = this._lexer.token; this.expectKeyword("extend"), this.expectKeyword("interface"); const n = this.parseName(), r = this.parseImplementsInterfaces(), i = this.parseConstDirectives(), s = this.parseFieldsDefinition(); if (r.length === 0 && i.length === 0 && s.length === 0) throw this.unexpected(); return this.node(t, { kind: x.INTERFACE_TYPE_EXTENSION, name: n, interfaces: r, directives: i, fields: s }) } parseUnionTypeExtension() { const t = this._lexer.token; this.expectKeyword("extend"), this.expectKeyword("union"); const n = this.parseName(), r = this.parseConstDirectives(), i = this.parseUnionMemberTypes(); if (r.length === 0 && i.length === 0) throw this.unexpected(); return this.node(t, { kind: x.UNION_TYPE_EXTENSION, name: n, directives: r, types: i }) } parseEnumTypeExtension() { const t = this._lexer.token; this.expectKeyword("extend"), this.expectKeyword("enum"); const n = this.parseName(), r = this.parseConstDirectives(), i = this.parseEnumValuesDefinition(); if (r.length === 0 && i.length === 0) throw this.unexpected(); return this.node(t, { kind: x.ENUM_TYPE_EXTENSION, name: n, directives: r, values: i }) } parseInputObjectTypeExtension() { const t = this._lexer.token; this.expectKeyword("extend"), this.expectKeyword("input"); const n = this.parseName(), r = this.parseConstDirectives(), i = this.parseInputFieldsDefinition(); if (r.length === 0 && i.length === 0) throw this.unexpected(); return this.node(t, { kind: x.INPUT_OBJECT_TYPE_EXTENSION, name: n, directives: r, fields: i }) } parseDirectiveDefinition() { const t = this._lexer.token, n = this.parseDescription(); this.expectKeyword("directive"), this.expectToken(h.AT); const r = this.parseName(), i = this.parseArgumentDefs(), s = this.expectOptionalKeyword("repeatable"); this.expectKeyword("on"); const a = this.parseDirectiveLocations(); return this.node(t, { kind: x.DIRECTIVE_DEFINITION, description: n, name: r, arguments: i, repeatable: s, locations: a }) } parseDirectiveLocations() { return this.delimitedMany(h.PIPE, this.parseDirectiveLocation) } parseDirectiveLocation() { const t = this._lexer.token, n = this.parseName(); if (Object.prototype.hasOwnProperty.call(yt, n.value)) return n; throw this.unexpected(t) } node(t, n) { return this._options.noLocation !== !0 && (n.loc = new Vi(t, this._lexer.lastToken, this._lexer.source)), n } peek(t) { return this._lexer.token.kind === t } expectToken(t) { const n = this._lexer.token; if (n.kind === t) return this.advanceLexer(), n; throw ee(this._lexer.source, n.start, `Expected ${On(t)}, found ${He(n)}.`) } expectOptionalToken(t) { return this._lexer.token.kind === t ? (this.advanceLexer(), !0) : !1 } expectKeyword(t) { const n = this._lexer.token; if (n.kind === h.NAME && n.value === t) this.advanceLexer(); else throw ee(this._lexer.source, n.start, `Expected "${t}", found ${He(n)}.`) } expectOptionalKeyword(t) { const n = this._lexer.token; return n.kind === h.NAME && n.value === t ? (this.advanceLexer(), !0) : !1 } unexpected(t) { const n = t ?? this._lexer.token; return ee(this._lexer.source, n.start, `Unexpected ${He(n)}.`) } any(t, n, r) { this.expectToken(t); const i = []; for (; !this.expectOptionalToken(r);)i.push(n.call(this)); return i } optionalMany(t, n, r) { if (this.expectOptionalToken(t)) { const i = []; do i.push(n.call(this)); while (!this.expectOptionalToken(r)); return i } return [] } many(t, n, r) { this.expectToken(t); const i = []; do i.push(n.call(this)); while (!this.expectOptionalToken(r)); return i } delimitedMany(t, n) { this.expectOptionalToken(t); const r = []; do r.push(n.call(this)); while (this.expectOptionalToken(t)); return r } advanceLexer() { const { maxTokens: t } = this._options, n = this._lexer.advance(); if (t !== void 0 && n.kind !== h.EOF && (++this._tokenCounter, this._tokenCounter > t)) throw ee(this._lexer.source, n.start, `Document contains more that ${t} tokens. Parsing aborted.`) } } function He(e) { const t = e.value; return On(e.kind) + (t != null ? ` "${t}"` : "") } function On(e) { return Ji(e) ? `"${e}"` : e } function vr(e) { return `"${e.replace(yr, _r)}"` } const yr = /[\x00-\x1f\x22\x5c\x7f-\x9f]/g; function _r(e) { return Er[e.charCodeAt(0)] } const Er = ["\\u0000", "\\u0001", "\\u0002", "\\u0003", "\\u0004", "\\u0005", "\\u0006", "\\u0007", "\\b", "\\t", "\\n", "\\u000B", "\\f", "\\r", "\\u000E", "\\u000F", "\\u0010", "\\u0011", "\\u0012", "\\u0013", "\\u0014", "\\u0015", "\\u0016", "\\u0017", "\\u0018", "\\u0019", "\\u001A", "\\u001B", "\\u001C", "\\u001D", "\\u001E", "\\u001F", "", "", '\\"', "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "\\\\", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "\\u007F", "\\u0080", "\\u0081", "\\u0082", "\\u0083", "\\u0084", "\\u0085", "\\u0086", "\\u0087", "\\u0088", "\\u0089", "\\u008A", "\\u008B", "\\u008C", "\\u008D", "\\u008E", "\\u008F", "\\u0090", "\\u0091", "\\u0092", "\\u0093", "\\u0094", "\\u0095", "\\u0096", "\\u0097", "\\u0098", "\\u0099", "\\u009A", "\\u009B", "\\u009C", "\\u009D", "\\u009E", "\\u009F"], gr = Object.freeze({}); function br(e, t, n = _n) { const r = new Map; for (const v of Object.values(x)) r.set(v, Tr(t, v)); let i, s = Array.isArray(e), a = [e], c = -1, l = [], f = e, u, y; const m = [], I = []; do { c++; const v = c === a.length, b = v && l.length !== 0; if (v) { if (u = I.length === 0 ? void 0 : m[m.length - 1], f = y, y = I.pop(), b) if (s) { f = f.slice(); let j = 0; for (const [te, w] of l) { const B = te - j; w === null ? (f.splice(B, 1), j++) : f[B] = w; } } else { f = Object.defineProperties({}, Object.getOwnPropertyDescriptors(f)); for (const [j, te] of l) f[j] = te; } c = i.index, a = i.keys, l = i.edits, s = i.inArray, i = i.prev; } else if (y) { if (u = s ? c : a[c], f = y[u], f == null) continue; m.push(u); } let C; if (!Array.isArray(f)) { var k, D; Yt(f) || Ye(!1, `Invalid AST Node: ${wt(f)}.`); const j = v ? (k = r.get(f.kind)) === null || k === void 0 ? void 0 : k.leave : (D = r.get(f.kind)) === null || D === void 0 ? void 0 : D.enter; if (C = j == null ? void 0 : j.call(t, f, u, y, m, I), C === gr) break; if (C === !1) { if (!v) { m.pop(); continue } } else if (C !== void 0 && (l.push([u, C]), !v)) if (Yt(C)) f = C; else { m.pop(); continue } } if (C === void 0 && b && l.push([u, f]), v) m.pop(); else { var G; i = { inArray: s, index: c, keys: a, edits: l, prev: i }, s = Array.isArray(f), a = s ? f : (G = n[f.kind]) !== null && G !== void 0 ? G : [], c = -1, l = [], y && I.push(y), y = f; } } while (i !== void 0); return l.length !== 0 ? l[l.length - 1][1] : e } function Tr(e, t) { const n = e[t]; return typeof n == "object" ? n : typeof n == "function" ? { enter: n, leave: void 0 } : { enter: e.enter, leave: e.leave } } function Nr(e) { return br(e, Or) } const kr = 80, Or = {
        Name: { leave: e => e.value }, Variable: { leave: e => "$" + e.name }, Document: {
            leave: e => N(e.definitions, `

`)
        }, OperationDefinition: { leave(e) { const t = F("(", N(e.variableDefinitions, ", "), ")"), n = N([e.operation, N([e.name, t]), N(e.directives, " ")], " "); return (n === "query" ? "" : n + " ") + e.selectionSet } }, VariableDefinition: { leave: ({ variable: e, type: t, defaultValue: n, directives: r }) => e + ": " + t + F(" = ", n) + F(" ", N(r, " ")) }, SelectionSet: { leave: ({ selections: e }) => ue(e) }, Field: {
            leave({ alias: e, name: t, arguments: n, directives: r, selectionSet: i }) {
                const s = F("", e, ": ") + t; let a = s + F("(", N(n, ", "), ")"); return a.length > kr && (a = s + F(`(
`, Je(N(n, `
`)), `
)`)), N([a, N(r, " "), i], " ")
            }
        }, Argument: { leave: ({ name: e, value: t }) => e + ": " + t }, FragmentSpread: { leave: ({ name: e, directives: t }) => "..." + e + F(" ", N(t, " ")) }, InlineFragment: { leave: ({ typeCondition: e, directives: t, selectionSet: n }) => N(["...", F("on ", e), N(t, " "), n], " ") }, FragmentDefinition: { leave: ({ name: e, typeCondition: t, variableDefinitions: n, directives: r, selectionSet: i }) => `fragment ${e}${F("(", N(n, ", "), ")")} on ${t} ${F("", N(r, " "), " ")}` + i }, IntValue: { leave: ({ value: e }) => e }, FloatValue: { leave: ({ value: e }) => e }, StringValue: { leave: ({ value: e, block: t }) => t ? Wi(e) : vr(e) }, BooleanValue: { leave: ({ value: e }) => e ? "true" : "false" }, NullValue: { leave: () => "null" }, EnumValue: { leave: ({ value: e }) => e }, ListValue: { leave: ({ values: e }) => "[" + N(e, ", ") + "]" }, ObjectValue: { leave: ({ fields: e }) => "{" + N(e, ", ") + "}" }, ObjectField: { leave: ({ name: e, value: t }) => e + ": " + t }, Directive: { leave: ({ name: e, arguments: t }) => "@" + e + F("(", N(t, ", "), ")") }, NamedType: { leave: ({ name: e }) => e }, ListType: { leave: ({ type: e }) => "[" + e + "]" }, NonNullType: { leave: ({ type: e }) => e + "!" }, SchemaDefinition: {
            leave: ({ description: e, directives: t, operationTypes: n }) => F("", e, `
`) + N(["schema", N(t, " "), ue(n)], " ")
        }, OperationTypeDefinition: { leave: ({ operation: e, type: t }) => e + ": " + t }, ScalarTypeDefinition: {
            leave: ({ description: e, name: t, directives: n }) => F("", e, `
`) + N(["scalar", t, N(n, " ")], " ")
        }, ObjectTypeDefinition: {
            leave: ({ description: e, name: t, interfaces: n, directives: r, fields: i }) => F("", e, `
`) + N(["type", t, F("implements ", N(n, " & ")), N(r, " "), ue(i)], " ")
        }, FieldDefinition: {
            leave: ({ description: e, name: t, arguments: n, type: r, directives: i }) => F("", e, `
`) + t + (Qt(n) ? F(`(
`, Je(N(n, `
`)), `
)`) : F("(", N(n, ", "), ")")) + ": " + r + F(" ", N(i, " "))
        }, InputValueDefinition: {
            leave: ({ description: e, name: t, type: n, defaultValue: r, directives: i }) => F("", e, `
`) + N([t + ": " + n, F("= ", r), N(i, " ")], " ")
        }, InterfaceTypeDefinition: {
            leave: ({ description: e, name: t, interfaces: n, directives: r, fields: i }) => F("", e, `
`) + N(["interface", t, F("implements ", N(n, " & ")), N(r, " "), ue(i)], " ")
        }, UnionTypeDefinition: {
            leave: ({ description: e, name: t, directives: n, types: r }) => F("", e, `
`) + N(["union", t, N(n, " "), F("= ", N(r, " | "))], " ")
        }, EnumTypeDefinition: {
            leave: ({ description: e, name: t, directives: n, values: r }) => F("", e, `
`) + N(["enum", t, N(n, " "), ue(r)], " ")
        }, EnumValueDefinition: {
            leave: ({ description: e, name: t, directives: n }) => F("", e, `
`) + N([t, N(n, " ")], " ")
        }, InputObjectTypeDefinition: {
            leave: ({ description: e, name: t, directives: n, fields: r }) => F("", e, `
`) + N(["input", t, N(n, " "), ue(r)], " ")
        }, DirectiveDefinition: {
            leave: ({ description: e, name: t, arguments: n, repeatable: r, locations: i }) => F("", e, `
`) + "directive @" + t + (Qt(n) ? F(`(
`, Je(N(n, `
`)), `
)`) : F("(", N(n, ", "), ")")) + (r ? " repeatable" : "") + " on " + N(i, " | ")
        }, SchemaExtension: { leave: ({ directives: e, operationTypes: t }) => N(["extend schema", N(e, " "), ue(t)], " ") }, ScalarTypeExtension: { leave: ({ name: e, directives: t }) => N(["extend scalar", e, N(t, " ")], " ") }, ObjectTypeExtension: { leave: ({ name: e, interfaces: t, directives: n, fields: r }) => N(["extend type", e, F("implements ", N(t, " & ")), N(n, " "), ue(r)], " ") }, InterfaceTypeExtension: { leave: ({ name: e, interfaces: t, directives: n, fields: r }) => N(["extend interface", e, F("implements ", N(t, " & ")), N(n, " "), ue(r)], " ") }, UnionTypeExtension: { leave: ({ name: e, directives: t, types: n }) => N(["extend union", e, N(t, " "), F("= ", N(n, " | "))], " ") }, EnumTypeExtension: { leave: ({ name: e, directives: t, values: n }) => N(["extend enum", e, N(t, " "), ue(n)], " ") }, InputObjectTypeExtension: { leave: ({ name: e, directives: t, fields: n }) => N(["extend input", e, N(t, " "), ue(n)], " ") }
    }; function N(e, t = "") { var n; return (n = e == null ? void 0 : e.filter(r => r).join(t)) !== null && n !== void 0 ? n : "" } function ue(e) {
        return F(`{
`, Je(N(e, `
`)), `
}`)
    } function F(e, t, n = "") { return t != null && t !== "" ? e + t + n : "" } function Je(e) {
        return F("  ", e.replace(/\n/g, `
  `))
    } function Qt(e) {
        var t; return (t = e == null ? void 0 : e.some(n => n.includes(`
`))) !== null && t !== void 0 ? t : !1
    } const Xt = "Accept", Et = "Content-Type", gt = "application/json", wn = "application/graphql-response+json", Zt = e => e.replace(/([\s,]|#[^\n\r]+)+/g, " ").trim(), wr = e => { const t = e.toLowerCase(); return t.includes(wn) || t.includes(gt) }, Kt = e => {
        try {
            if (Array.isArray(e)) return { _tag: "Batch", executionResults: e.map(en) }; if (We(e)) return { _tag: "Single", executionResult: en(e) }; throw new Error(`Invalid execution result: result is not object or array. 
Got:
${String(e)}`)
        } catch (t) { return t }
    }, en = e => { if (typeof e != "object" || e === null) throw new Error("Invalid execution result: result is not object"); let t, n, r; if ("errors" in e) { if (!We(e.errors) && !Array.isArray(e.errors)) throw new Error("Invalid execution result: errors is not plain object OR array"); t = e.errors; } if ("data" in e) { if (!We(e.data) && e.data !== null) throw new Error("Invalid execution result: data is not plain object"); n = e.data; } if ("extensions" in e) { if (!We(e.extensions)) throw new Error("Invalid execution result: extensions is not plain object"); r = e.extensions; } return { data: n, errors: t, extensions: r } }, Sr = e => e._tag === "Batch" ? e.executionResults.some(tn) : tn(e.executionResult), tn = e => Array.isArray(e.errors) ? e.errors.length > 0 : !!e.errors, Sn = e => typeof e == "object" && e !== null && "kind" in e && e.kind === x.OPERATION_DEFINITION, xr = e => { var r; let t; const n = e.definitions.filter(Sn); return n.length === 1 && (t = (r = n[0].name) == null ? void 0 : r.value), t }, Ir = e => { let t = !1; const n = e.definitions.filter(Sn); return n.length === 1 && (t = n[0].operation === be.MUTATION), t }, ut = (e, t) => { const n = typeof e == "string" ? e : Nr(e); let r = !1, i; if (t) return { expression: n, isMutation: r, operationName: i }; const s = Li(() => typeof e == "string" ? hr(e) : e); return s instanceof Error ? { expression: n, isMutation: r, operationName: i } : (i = xr(s), r = Ir(s), { expression: n, operationName: i, isMutation: r }) }, St = JSON, dt = async e => { const t = { ...e, method: e.request._tag === "Single" ? e.request.document.isMutation ? "POST" : zt(e.method ?? "post") : e.request.hasMutations ? "POST" : zt(e.method ?? "post"), fetchOptions: { ...e.fetchOptions, errorPolicy: e.fetchOptions.errorPolicy ?? "none" } }, r = await Cr(t.method)(t); if (!r.ok) return new Ie({ status: r.status, headers: r.headers }, { query: e.request._tag === "Single" ? e.request.document.expression : e.request.query, variables: e.request.variables }); const i = await Ar(r, e.fetchOptions.jsonSerializer ?? St); if (i instanceof Error) throw i; const s = { status: r.status, headers: r.headers }; if (Sr(i) && t.fetchOptions.errorPolicy === "none") { const a = i._tag === "Batch" ? { ...i.executionResults, ...s } : { ...i.executionResult, ...s }; return new Ie(a, { query: e.request._tag === "Single" ? e.request.document.expression : e.request.query, variables: e.request.variables }) } switch (i._tag) { case "Single": return { ...s, ...nn(t)(i.executionResult) }; case "Batch": return { ...s, data: i.executionResults.map(nn(t)) }; default: kt(i); } }, nn = e => t => ({ extensions: t.extensions, data: t.data, errors: e.fetchOptions.errorPolicy === "all" ? t.errors : void 0 }), Ar = async (e, t) => { const n = e.headers.get(Et), r = await e.text(); return n && wr(n) ? Kt(t.parse(r)) : Kt(r) }, Cr = e => async t => { const n = new Headers(t.headers); let r = null, i; n.has(Xt) || n.set(Xt, [wn, gt].join(", ")), e === "POST" ? (i = (t.fetchOptions.jsonSerializer ?? St).stringify(Dr(t)), typeof i == "string" && !n.has(Et) && n.set(Et, gt)) : r = Lr(t); const s = { method: e, headers: n, body: i, ...t.fetchOptions }; let a = new URL(t.url), c = s; if (t.middleware) { const f = await Promise.resolve(t.middleware({ ...s, url: t.url, operationName: t.request._tag === "Single" ? t.request.document.operationName : void 0, variables: t.request.variables })), { url: u, ...y } = f; a = new URL(u), c = y; } return r && r.forEach((f, u) => { a.searchParams.append(u, f); }), await (t.fetch ?? fetch)(a, c) }, Dr = e => { switch (e.request._tag) { case "Single": return { query: e.request.document.expression, variables: e.request.variables, operationName: e.request.document.operationName }; case "Batch": return mn(e.request.query, e.request.variables ?? []).map(([t, n]) => ({ query: t, variables: n })); default: throw kt(e.request) } }, Lr = e => { var r; const t = e.fetchOptions.jsonSerializer ?? St, n = new URLSearchParams; switch (e.request._tag) { case "Single": return n.append("query", Zt(e.request.document.expression)), e.request.variables && n.append("variables", t.stringify(e.request.variables)), e.request.document.operationName && n.append("operationName", e.request.document.operationName), n; case "Batch": { const i = ((r = e.request.variables) == null ? void 0 : r.map(c => t.stringify(c))) ?? [], s = e.request.query.map(Zt), a = mn(s, i).map(([c, l]) => ({ query: c, variables: l })); return n.append("query", t.stringify(a)), n } default: throw kt(e.request) } }; class Rr { constructor(t, n = {}) { ce(this, "url"); ce(this, "requestConfig"); ce(this, "rawRequest", async (...t) => { const [n, r, i] = t, s = Pi(n, r, i), { headers: a, fetch: c = globalThis.fetch, method: l = "POST", requestMiddleware: f, responseMiddleware: u, excludeOperationName: y, ...m } = this.requestConfig, { url: I } = this; s.signal !== void 0 && (m.signal = s.signal); const k = ut(s.query, y), D = await dt({ url: I, request: { _tag: "Single", document: k, variables: s.variables }, headers: { ...xe(lt(a)), ...xe(s.requestHeaders) }, fetch: c, method: l, fetchOptions: m, middleware: f }); if (u && await u(D, { operationName: k.operationName, variables: r, url: this.url }), D instanceof Error) throw D; return D }); this.url = t, this.requestConfig = n; } async request(t, ...n) { const [r, i] = n, s = Mr(t, r, i), { headers: a, fetch: c = globalThis.fetch, method: l = "POST", requestMiddleware: f, responseMiddleware: u, excludeOperationName: y, ...m } = this.requestConfig, { url: I } = this; s.signal !== void 0 && (m.signal = s.signal); const k = ut(s.document, y), D = await dt({ url: I, request: { _tag: "Single", document: k, variables: s.variables }, headers: { ...xe(lt(a)), ...xe(s.requestHeaders) }, fetch: c, method: l, fetchOptions: m, middleware: f }); if (u && await u(D, { operationName: k.operationName, variables: s.variables, url: this.url }), D instanceof Error) throw D; return D.data } async batchRequests(t, n) { const r = Mi(t, n), { headers: i, excludeOperationName: s, ...a } = this.requestConfig; r.signal !== void 0 && (a.signal = r.signal); const c = r.documents.map(({ document: m }) => ut(m, s)), l = c.map(({ expression: m }) => m), f = c.some(({ isMutation: m }) => m), u = r.documents.map(({ variables: m }) => m), y = await dt({ url: this.url, request: { _tag: "Batch", operationName: void 0, query: l, hasMutations: f, variables: u }, headers: { ...xe(lt(i)), ...xe(r.requestHeaders) }, fetch: this.requestConfig.fetch ?? globalThis.fetch, method: this.requestConfig.method || "POST", fetchOptions: a, middleware: this.requestConfig.requestMiddleware }); if (this.requestConfig.responseMiddleware && await this.requestConfig.responseMiddleware(y, { operationName: void 0, variables: u, url: this.url }), y instanceof Error) throw y; return y.data } setHeaders(t) { return this.requestConfig.headers = t, this } setHeader(t, n) { const { headers: r } = this.requestConfig; return r ? r[t] = n : this.requestConfig.headers = { [t]: n }, this } setEndpoint(t) { return this.url = t, this } } const Mr = (e, t, n) => e.document ? e : { document: e, variables: t, requestHeaders: n, signal: void 0 }, Pr = `query ($ids: String) {
    animes(ids: $ids) {
        english
        episodes
        episodesAired
        id
        isCensored
        japanese
        kind
        licenseNameRu
        malId
        name
        nextEpisodeAt
        related {
            anime {
                id
            }
            id
            relationKind
        }
        releasedOn {
            date
        }
        russian
        status
        synonyms
        updatedAt
        url
        userRate { id episodes status }
    }
}
`, Fr = { kind: "Document", definitions: [{ kind: "OperationDefinition", operation: "query", variableDefinitions: [{ kind: "VariableDefinition", variable: { kind: "Variable", name: { kind: "Name", value: "ids" } }, type: { kind: "NamedType", name: { kind: "Name", value: "String" } }, directives: [] }], directives: [], selectionSet: { kind: "SelectionSet", selections: [{ kind: "Field", name: { kind: "Name", value: "animes" }, arguments: [{ kind: "Argument", name: { kind: "Name", value: "ids" }, value: { kind: "Variable", name: { kind: "Name", value: "ids" } } }], directives: [], selectionSet: { kind: "SelectionSet", selections: [{ kind: "Field", name: { kind: "Name", value: "english" }, arguments: [], directives: [] }, { kind: "Field", name: { kind: "Name", value: "episodes" }, arguments: [], directives: [] }, { kind: "Field", name: { kind: "Name", value: "episodesAired" }, arguments: [], directives: [] }, { kind: "Field", name: { kind: "Name", value: "id" }, arguments: [], directives: [] }, { kind: "Field", name: { kind: "Name", value: "isCensored" }, arguments: [], directives: [] }, { kind: "Field", name: { kind: "Name", value: "japanese" }, arguments: [], directives: [] }, { kind: "Field", name: { kind: "Name", value: "kind" }, arguments: [], directives: [] }, { kind: "Field", name: { kind: "Name", value: "licenseNameRu" }, arguments: [], directives: [] }, { kind: "Field", name: { kind: "Name", value: "malId" }, arguments: [], directives: [] }, { kind: "Field", name: { kind: "Name", value: "name" }, arguments: [], directives: [] }, { kind: "Field", name: { kind: "Name", value: "nextEpisodeAt" }, arguments: [], directives: [] }, { kind: "Field", name: { kind: "Name", value: "related" }, arguments: [], directives: [], selectionSet: { kind: "SelectionSet", selections: [{ kind: "Field", name: { kind: "Name", value: "anime" }, arguments: [], directives: [], selectionSet: { kind: "SelectionSet", selections: [{ kind: "Field", name: { kind: "Name", value: "id" }, arguments: [], directives: [] }] } }, { kind: "Field", name: { kind: "Name", value: "id" }, arguments: [], directives: [] }, { kind: "Field", name: { kind: "Name", value: "relationKind" }, arguments: [], directives: [] }] } }, { kind: "Field", name: { kind: "Name", value: "releasedOn" }, arguments: [], directives: [], selectionSet: { kind: "SelectionSet", selections: [{ kind: "Field", name: { kind: "Name", value: "date" }, arguments: [], directives: [] }] } }, { kind: "Field", name: { kind: "Name", value: "russian" }, arguments: [], directives: [] }, { kind: "Field", name: { kind: "Name", value: "status" }, arguments: [], directives: [] }, { kind: "Field", name: { kind: "Name", value: "synonyms" }, arguments: [], directives: [] }, { kind: "Field", name: { kind: "Name", value: "updatedAt" }, arguments: [], directives: [] }, { kind: "Field", name: { kind: "Name", value: "url" }, arguments: [], directives: [] }, { kind: "Field", name: { kind: "Name", value: "userRate" }, arguments: [], directives: [], selectionSet: { kind: "SelectionSet", selections: [{ kind: "Field", name: { kind: "Name", value: "id" }, arguments: [], directives: [] }, { kind: "Field", name: { kind: "Name", value: "episodes" }, arguments: [], directives: [] }, { kind: "Field", name: { kind: "Name", value: "status" }, arguments: [], directives: [] }] } }] } }] } }], loc: { start: 0, end: 566, source: { name: "GraphQL request", locationOffset: { line: 1, column: 1 }, body: Pr } } }, Br = "https://shikimori.one/api/graphql", jr = new Rr(Br); async function $r(e) { return (await jr.request(Fr, { ids: e })).animes } class Ur { constructor(t) { ce(this, "title"); ce(this, "options", { linkParams: {} }); ce(this, "data", vue.reactive({})); ce(this, "translations", vue.reactive({})); this.title = t; } async init(t) { return this } } class Vr extends Ur { constructor() { super("Kodik"); ce(this, "client"); this.client = kodikwrapper.Client.fromToken("447d179e875efe44217f20d1ee2146be"), this.options.linkParams = { translations: !1 }; } async init(n) { var r; try { const i = await ((r = this.client) == null ? void 0 : r.search({ shikimori_id: +n.id, with_episodes: !0 })), s = i.results; if (!s.length) return console.warn(this.title, "Переводы не найдены"); this.data = i; const a = s.map(c => { var l; if (c.type === "anime") return { id: c.translation.id, title: c.translation.title, type: c.translation.type, balancer: this.title, data: { link: c.link, quality: c.quality } }; { const f = (l = c.seasons) == null ? void 0 : l[c.last_season || 1], u = Object.keys(f.episodes || {}); return { id: c.translation.id, title: c.translation.title, type: c.translation.type, balancer: this.title, data: { quality: c.quality, episodes: f.episodes, totalEpisodes: { start: Number(u.at(0)), end: Number(u.at(-1)) } } } } }); this.translations = { voice: a.filter(c => c.type === "voice"), subtitles: a.filter(c => c.type === "subtitles") }; } catch (i) { console.error("Ошибка при инициализации Kodik", i); } return this } } const Ce = pinia.defineStore("main", { state: () => ({ anime: {}, data: { totalEpisodes: 0 }, balancers: { Kodik: new Vr } }), getters: { getBalancerByTitle(e) { return t => e.balancers[t] }, getBalancers(e) { return Object.values(e.balancers) } }, actions: { async initBalancers() { var u, y; const e = (await $r($(".b-user_rate").data("entry").id.toString()))[0], t = me(), { translationsSorted: n } = pinia.storeToRefs(t); nt().setHasEpisodes(e && e.status !== "anons" && (e.status === "ongoing" && e.episodes === 0 || e.episodes > 1)), this.anime = e, this.data.totalEpisodes = e.status === "released" ? e.episodes : (e == null ? void 0 : e.episodesAired) || 0; const i = new URLSearchParams(window.location.search), s = i.get("balancer"), a = i.get("translation_type"), c = i.get("episode"), l = i.get("team"); if (c) t.setEpisode(+c); else { const m = ((u = e == null ? void 0 : e.userRate) == null ? void 0 : u.episodes) || 0; t.setEpisode(e != null && e.userRate ? ((y = e.userRate) == null ? void 0 : y.status) !== "completed" ? m + 1 : this.data.totalEpisodes : 1); } for (const m of Object.values(this.balancers)) await m.init(this.anime); s ? t.setBalancerName(s) : t.setBalancerName("Kodik"), a ? t.setTranslationType(a) : t.setTranslationType("voice"); const f = n.value; if (l) { const m = f.find(I => I.id === +l); if (!m) return; t.setTranslation(m); } else t.setTranslation(f[0] || null); } } }), me = pinia.defineStore("selected", { state: () => ({ balancerName: null, translationType: null, episode: 0, prevTranslation: null, translation: null }), getters: { getBalancer({ balancerName: e }) { return e !== null ? Ce().balancers[e] : null }, translationWasChanged({ prevTranslation: e, translation: t }) { return e !== t }, translationsSorted({ translationType: e, balancerName: t }) { var n; if (t !== null) { const r = Ce(), { balancers: i } = pinia.storeToRefs(r); return [...((n = i.value[t]) == null ? void 0 : n.translations[e || "unknown"]) || []].sort((s, a) => s.title.localeCompare(a.title, "en-US")) } return [] }, totalEpisodes({ translation: e }) { var t; return e ? e.data.totalEpisodes ? ((((t = e.data.totalEpisodes) == null ? void 0 : t.end) || 0) - e.data.totalEpisodes.start || 0) + 1 : e.data.link ? 1 : 0 : 0 } }, actions: { setBalancerName(e) { this.balancerName = e; }, setTranslationType(e) { this.translationType = e; }, setEpisode(e) { this.episode = e, rn({ episode: String(e) }); }, setTranslation(e) { var r; this.prevTranslation = this.translation, this.translation = e; const { start: t = 1, end: n = 1 } = ((r = e == null ? void 0 : e.data) == null ? void 0 : r.totalEpisodes) || {}; this.setEpisode(Math.max(t, Math.min(this.episode, n))), rn({ balancer: String(e == null ? void 0 : e.balancer), team: String(e == null ? void 0 : e.id), translation_type: String(e == null ? void 0 : e.type) }); }, isMissingEpisode(e) { var n, r; const t = (r = (n = this.translation) == null ? void 0 : n.data) == null ? void 0 : r.totalEpisodes; return t && (t.start > e || t.end < e) } } }); function rn(e) { const t = new URLSearchParams(window.location.search); for (const [r, i] of Object.entries(e)) t.set(r, i); const n = window.location.pathname + "?" + t.toString(); history.pushState({ path: n }, "", n); } const qr = { class: "sp-viewport" }, zr = { id: "anime_video", class: "sp-viewport_video-player", "data-video-player": "" }, Gr = ["src"], Hr = vue.defineComponent({ __name: "PlayerContent", setup(e) { const t = me(), { translation: n, episode: r, getBalancer: i } = pinia.storeToRefs(t), s = vue.computed(() => { var m, I, k, D; const l = n.value, f = ((I = (m = l == null ? void 0 : l.data) == null ? void 0 : m.episodes) == null ? void 0 : I[r.value]) || ((k = l == null ? void 0 : l.data) == null ? void 0 : k.link); if (!f) return ""; const u = new URLSearchParams, y = ((D = i.value) == null ? void 0 : D.options.linkParams) || {}; for (const [G, v] of Object.entries(y)) u.set(G, v); return (typeof f == "object" ? f == null ? void 0 : f.link : f) + `?${u.toString()}` }), a = vue.ref(!0), c = l => { var f, u; ((f = l.data) == null ? void 0 : f.key) === "kodik_player_pause" ? a.value = !0 : ((u = l.data) == null ? void 0 : u.key) === "kodik_player_play" && (a.value = !1); }; return vue.onMounted(() => { window.addEventListener("message", c); }), vue.onUnmounted(() => { window.removeEventListener("message", c); }), (l, f) => (vue.openBlock(), vue.createElementBlock("div", qr, [vue.createElementVNode("div", zr, [vue.createElementVNode("iframe", { class: "sp-viewport_iframe", src: s.value, frameborder: "0", allowfullscreen: "" }, null, 8, Gr)]), vue.createVNode(Ci, { "is-ui-visible": a.value }, null, 8, ["is-ui-visible"])])) } }), Wr = ["data-title"], Yr = vue.defineComponent({ __name: "BalancerItem", props: { active: { type: Boolean }, disabled: { type: Boolean }, content: {} }, setup(e) { return (t, n) => (vue.openBlock(), vue.createElementBlock("div", { class: vue.normalizeClass(["b-tag", { active: t.active, disabled: t.disabled }, "balancer"]), "data-title": t.content, href: "" }, [vue.createElementVNode("span", null, vue.toDisplayString(t.content), 1)], 10, Wr)) } }), Jr = { class: "sp-balancers" }, Qr = { class: "title" }, Xr = { class: "list" }, Zr = vue.defineComponent({ __name: "BalancerList", setup(e) { const t = vue.ref("Плеер"), n = Ce(), { getBalancers: r } = pinia.storeToRefs(n), i = me(), { balancerName: s } = pinia.storeToRefs(i); return (a, c) => (vue.openBlock(), vue.createElementBlock("div", Jr, [vue.createElementVNode("div", Qr, vue.toDisplayString(t.value), 1), vue.createElementVNode("div", Xr, [(vue.openBlock(!0), vue.createElementBlock(vue.Fragment, null, vue.renderList(vue.unref(r), (l, f) => (vue.openBlock(), vue.createBlock(Yr, vue.mergeProps({ key: f, ref_for: !0 }, { content: l.title, active: vue.unref(s) === l.title }, { onClick: u => vue.unref(i).setBalancerName(l.title) }), null, 16, ["onClick"]))), 128))])])) } }), Kr = { key: 0, class: "size tiny" }, es = ["data-title"], ts = vue.defineComponent({ __name: "TranslationItem", props: { active: { type: Boolean }, disabled: { type: Boolean }, content: {}, size: {} }, setup(e) { return (t, n) => (vue.openBlock(), vue.createElementBlock("a", { class: vue.normalizeClass(["b-menu-line", "entry", "b-link", { active: t.active, disabled: t.disabled }]) }, [t.size !== 0 ? (vue.openBlock(), vue.createElementBlock("span", Kr, vue.toDisplayString(t.size), 1)) : vue.createCommentVNode("", !0), vue.createElementVNode("span", { class: "name", "data-title": t.content }, vue.toDisplayString(t.content), 9, es)], 2)) } }), ns = { class: "sp-translations" }, is = { "data-scroll-container": "" }, rs = { class: "inner", "data-scroll-content": "" }, ss = vue.defineComponent({ __name: "TranslationList", setup(e) { const t = me(), { translation: n, translationsSorted: r } = pinia.storeToRefs(t), i = a => { var c; return a.data.totalEpisodes ? (((c = a.data.totalEpisodes) == null ? void 0 : c.end) - a.data.totalEpisodes.start || 0) + 1 : a.data.link ? 1 : 0 }, s = a => { let c = "1 эпизод"; return !a.data.link && a.data.totalEpisodes && (c = (a.data.totalEpisodes.start === a.data.totalEpisodes.end ? `${a.data.totalEpisodes.start}` : `с ${a.data.totalEpisodes.start} по ${a.data.totalEpisodes.end}`) + " эпизод"), "quality" in a.data && (c += ` [${a.data.quality}]`), c }; return (a, c) => { const l = vue.resolveDirective("scroll-to"); return vue.openBlock(), vue.createElementBlock("div", ns, [vue.createElementVNode("div", is, [vue.createElementVNode("div", rs, [(vue.openBlock(!0), vue.createElementBlock(vue.Fragment, null, vue.renderList(vue.unref(r), (f, u) => { var y, m, I, k; return vue.withDirectives((vue.openBlock(), vue.createBlock(ts, vue.mergeProps({ key: u, ref_for: !0 }, { content: f.title, active: vue.unref(n) === f, size: i(f) }, { "data-ep-start": ((m = (y = f.data) == null ? void 0 : y.totalEpisodes) == null ? void 0 : m.start) || 1, "data-ep-end": ((k = (I = f.data) == null ? void 0 : I.totalEpisodes) == null ? void 0 : k.end) || 1, title: s(f), onClick: D => vue.unref(t).setTranslation(f) }), null, 16, ["data-ep-start", "data-ep-end", "title", "onClick"])), [[l, vue.unref(n) === f, void 0, { mounted: !0, vertical: !0 }]]) }), 128))])])]) } } }), as = { class: "stat_name" }, os = ["data-total"], ls = vue.defineComponent({ __name: "TranslationTypeItem", props: { active: { type: Boolean }, content: {}, total: {} }, setup(e) { return (t, n) => (vue.openBlock(), vue.createElementBlock("div", as, [vue.createElementVNode("a", { class: vue.normalizeClass(["b-link", { active: t.active }]) }, [vue.createTextVNode(vue.toDisplayString(t.content), 1), vue.createElementVNode("span", { class: "size", "data-total": t.total }, vue.toDisplayString(t.total), 9, os)], 2)])) } }), cs = { class: "sp-tabs b-stats_bar" }, us = { class: "stat_names" }, ds = vue.defineComponent({ __name: "TranslationTypes", setup(e) { const t = me(), { translationType: n, getBalancer: r } = pinia.storeToRefs(t), i = vue.computed(() => { var c, l, f, u; const a = (c = r.value) == null ? void 0 : c.translations; return [{ id: 0, title: "Озвучка", type: "voice", total: ((l = a == null ? void 0 : a.voice) == null ? void 0 : l.length) || 0, hidden: !1 }, { id: 1, title: "Субтитры", type: "subtitles", total: ((f = a == null ? void 0 : a.subtitles) == null ? void 0 : f.length) || 0, hidden: !1 }, { id: 2, title: ". . .", type: "unknown", total: 0, hidden: (((u = a == null ? void 0 : a.unknown) == null ? void 0 : u.length) || 0) === 0 }].filter(y => !y.hidden) }), s = (a, c) => { c || t.setTranslationType(a); }; return (a, c) => (vue.openBlock(), vue.createElementBlock("div", cs, [vue.createElementVNode("div", us, [(vue.openBlock(!0), vue.createElementBlock(vue.Fragment, null, vue.renderList(i.value, l => (vue.openBlock(), vue.createBlock(ls, vue.mergeProps({ key: l.id, ref_for: !0 }, { content: l.title, total: l.total, active: vue.unref(n) === l.type }, { onClick: f => s(l.type, l.hidden) }), null, 16, ["onClick"]))), 128))])])) } }), fs = { class: "sp-sidebar" }, ps = { class: "sp-selection_panel" }, hs = { key: 0, class: "sp-buttons stretch" }, ms = { class: "sp-buttons group stretch" }, vs = { class: "number" }, ys = vue.defineComponent({ __name: "PlayerSidebar", setup(e) { const t = Ce(), { anime: n } = pinia.storeToRefs(t), r = me(), { episode: i } = pinia.storeToRefs(r), s = vue.computed(() => { var y, m; return (((m = (y = n.value) == null ? void 0 : y.userRate) == null ? void 0 : m.episodes) || 0) > i.value }), a = vue.computed(() => { var y, m; return ((m = (y = n.value) == null ? void 0 : y.userRate) == null ? void 0 : m.episodes) === i.value }), c = vue.computed(() => a.value ? freeSolidSvgIcons.faBookmark : s.value ? freeSolidSvgIcons.faEye : freeRegularSvgIcons.faBookmark), l = vue.computed(() => a.value ? "В закладках" : s.value ? "Просмотрен" : "В просмотренное"), f = async () => { var C, j; if (((j = (C = n.value) == null ? void 0 : C.userRate) == null ? void 0 : j.episodes) === i.value) return; const y = $(".b-user_rate.anime-" + n.value.id), m = y.data("view_object").model, I = y.find("form").data("method").toLowerCase(), k = { episodes: String(i.value) }; I === "post" ? k.status = "watching" : I === "patch" && (m.status === "completed" ? k.status = "rewatching" : i.value === n.value.episodes ? (k.status = "completed", m.status === "rewatching" && (k.rewatches = String(m.rewatches + 1))) : m.status !== "rewatching" && m.status !== "watching" && (k.status = "watching")); const G = await (await fetch(`/user_rates/${m.id}/edit`, { method: "GET" })).text(), v = new DOMParser().parseFromString(G, "text/html"), b = $(v).find("form"); b.find('input[name="user_rate[episodes]"]').val(k.episodes), "status" in k && b.find('select[name="user_rate[status]"]').val(k.status), "rewatches" in k && b.find('input[name="user_rate[rewatches]"]').val(k.rewatches), b.addClass("hidden"), y.find(".b-add_to_list").after(b), b.submit(); }; console.log($(document.body).data("user")); const u = vue.ref(!!$(document.body).data("user").id); return (y, m) => { const I = vue.resolveComponent("FaIcon"); return vue.openBlock(), vue.createElementBlock("div", fs, [vue.createElementVNode("div", ps, [vue.createVNode(Zr), vue.createVNode(ds), vue.createVNode(ss)]), u.value ? (vue.openBlock(), vue.createElementBlock("div", hs, [vue.createElementVNode("div", ms, [vue.createElementVNode("div", { class: vue.normalizeClass(["b-link_button", { watched: a.value }]), onClick: m[0] || (m[0] = k => f()) }, [vue.createVNode(I, { icon: c.value, class: "fa-sm" }, null, 8, ["icon"]), vue.createElementVNode("span", vs, vue.toDisplayString(l.value), 1)], 2)])])) : vue.createCommentVNode("", !0)]) } } }); var Pe = typeof GM_info < "u" ? GM_info : void 0; const _s = { class: "sp-footer" }, Es = ["data-name", "data-version", "data-version-major", "data-version-minor", "data-version-patch"], gs = { class: "name" }, bs = { class: "version" }, Ts = vue.defineComponent({ __name: "PlayerFooter", setup(e) { const t = Pe.script.version.split("."); return (n, r) => (vue.openBlock(), vue.createElementBlock("div", _s, [vue.createElementVNode("div", { class: "script-info", "data-name": vue.unref(Pe).script.name, "data-version": vue.unref(Pe).script.version, "data-version-major": vue.unref(t)[0], "data-version-minor": vue.unref(t)[1], "data-version-patch": vue.unref(t)[2] }, [vue.createElementVNode("span", gs, vue.toDisplayString(vue.unref(Pe).script.name), 1), vue.createElementVNode("span", bs, " v" + vue.toDisplayString(vue.unref(Pe).script.version), 1)], 8, Es)])) } }), Ns = ["data-episode-number"], ks = vue.defineComponent({ __name: "EpisodeItem", props: { active: { type: Boolean }, disabled: { type: Boolean }, episode: {}, watched: { type: Boolean } }, setup(e) { return (t, n) => { const r = vue.resolveComponent("FaIcon"); return vue.openBlock(), vue.createElementBlock("div", { class: vue.normalizeClass(["b-link_button", { dark: t.active || t.disabled, disabled: t.disabled }, { watched: t.watched }, "episode"]) }, [vue.createVNode(r, { icon: vue.unref(freeSolidSvgIcons.faBookmark), class: vue.normalizeClass(["fa-sm", { hidden: !t.watched }]) }, null, 8, ["icon", "class"]), vue.createElementVNode("span", { class: "number", "data-episode-number": t.episode }, vue.toDisplayString(t.episode) + " эпизод", 9, Ns)], 2) } } }), Os = { ref: "root", class: vue.normalizeClass(["sp-episodes_search"]) }, ws = { class: vue.normalizeClass(["sp-episodes_search_input"]) }, Ss = { class: vue.normalizeClass(["b-input", "integer"]) }, xs = ["min", "max", "icon-left"], Is = { key: 0, class: vue.normalizeClass(["found-episodes"]) }, As = { key: 0, class: vue.normalizeClass(["sp-episodes_search_buttons", "sp-buttons", "group"]) }, Cs = { class: "icon" }, Ds = { class: "icon" }, Ls = { class: "icon" }, Rs = vue.defineComponent({ __name: "PlayerEpisodesSearch", props: { episodes: {}, scrollContainer: { type: Function }, horizontal: { type: Boolean }, minEpisodeNumber: {}, maxEpisodeNumber: {} }, emits: ["hide-click"], setup(e, { emit: t }) { const n = e, r = t, i = vue.computed(() => n.horizontal ? freeSolidSvgIcons.faChevronLeft : freeSolidSvgIcons.faChevronUp), s = vue.computed(() => n.horizontal ? freeSolidSvgIcons.faChevronRight : freeSolidSvgIcons.faChevronDown); let a = 0; const c = vue.ref([]), l = vue.ref(0), f = vue.ref(""); let u = null, y = null; const m = () => { f.value = "", c.value = [], I(0, !0), r("hide-click", !1); }; vue.watch(f, (v, b) => { !b && u && (a = n.horizontal ? u.scrollLeft : u.scrollTop), v = v.toString().trim(), v.length && /\d+/.test(v) ? c.value = n.episodes.filter(C => String(C).includes(v)) : (G(a), c.value = []), I(0, !0); }); const I = (v, b = !1) => { let C; if (c.value.length) { l.value = v; const j = String(c.value[l.value]); if (j) { if (!u) return; C = u.querySelector(`[data-scroll-id="${j}"]`); let te = 0; n.horizontal ? te = C.offsetLeft - C.offsetWidth : te = C.offsetTop - C.offsetHeight, k(te); } } D(C, b); }, k = v => { u && (n.horizontal ? u.scrollLeft = v : u.scrollTop = v); }, D = (v, b) => { const C = "highlight", j = u == null ? void 0 : u.querySelector(`.${C}`); j && j.classList.remove(C), v && v.classList.add(C), b && y && y.focus(); }, G = v => { u && (n.horizontal ? u.scrollLeft = v : u.scrollTop = v); }; return vue.onMounted(() => { u = n.scrollContainer(), y = u == null ? void 0 : u.querySelector("input"); }), (v, b) => { const C = vue.resolveComponent("fa-icon"); return vue.openBlock(), vue.createElementBlock("div", Os, [vue.createElementVNode("div", ws, [vue.createElementVNode("div", Ss, [vue.withDirectives(vue.createElementVNode("input", { "onUpdate:modelValue": b[0] || (b[0] = j => f.value = j), class: vue.normalizeClass(["numeric", "integer"]), min: v.minEpisodeNumber, max: v.maxEpisodeNumber, "icon-left": v.horizontal ? void 0 : "search", placeholder: "№ Эпизода", inputmode: "numeric", pattern: "\\\\d*", type: "number" }, null, 8, xs), [[vue.vModelText, f.value]])]), f.value ? (vue.openBlock(), vue.createElementBlock("div", Is, vue.toDisplayString(l.value + 1) + " / " + vue.toDisplayString(c.value.length), 1)) : vue.createCommentVNode("", !0)]), b[3] || (b[3] = vue.createElementVNode("div", { class: "sp-divider vertical" }, null, -1)), v.horizontal || f.value ? (vue.openBlock(), vue.createElementBlock("div", As, [vue.createElementVNode("div", { class: "b-link_button is-icon", onClick: b[1] || (b[1] = () => { l.value < v.minEpisodeNumber || I(l.value - 1); }) }, [vue.createElementVNode("div", Cs, [vue.createVNode(C, { icon: i.value }, null, 8, ["icon"])])]), vue.createElementVNode("div", { class: "b-link_button is-icon", onClick: b[2] || (b[2] = () => { l.value + 2 > c.value.length || I(l.value + 1); }) }, [vue.createElementVNode("div", Ds, [vue.createVNode(C, { icon: s.value }, null, 8, ["icon"])])]), vue.createElementVNode("div", { class: "b-link_button is-icon", onClick: m }, [vue.createElementVNode("div", Ls, [vue.createVNode(C, { icon: vue.unref(freeSolidSvgIcons.faTimes) }, null, 8, ["icon"])])])])) : vue.createCommentVNode("", !0)], 512) } } }), Ms = { key: 0, class: vue.normalizeClass(["sp-episodes_buttons", "sp-buttons", "group"]) }, Ps = { class: "icon" }, Fs = vue.defineComponent({ __name: "EpisodesButtons", setup(e) { const t = nt(), { searchVisible: n } = pinia.storeToRefs(t), r = me(), { translation: i, totalEpisodes: s } = pinia.storeToRefs(r); return (a, c) => { var f, u, y, m; const l = vue.resolveComponent("FaIcon"); return vue.unref(n) ? (vue.openBlock(), vue.createBlock(Rs, { key: 0, episodes: Array.from({ length: vue.unref(s) }, (I, k) => { var D, G; return (((G = (D = vue.unref(i)) == null ? void 0 : D.data.totalEpisodes) == null ? void 0 : G.start) || 1) + k }), "scroll-container": () => a.$el.parentElement.querySelector("[data-scroll-content]"), horizontal: !0, "min-episode-number": ((u = (f = vue.unref(i)) == null ? void 0 : f.data.totalEpisodes) == null ? void 0 : u.start) || 1, "max-episode-number": ((m = (y = vue.unref(i)) == null ? void 0 : y.data.totalEpisodes) == null ? void 0 : m.end) || 1, onHideClick: c[1] || (c[1] = I => n.value = !1) }, null, 8, ["episodes", "scroll-container", "min-episode-number", "max-episode-number"])) : (vue.openBlock(), vue.createElementBlock("div", Ms, [vue.createElementVNode("div", { class: "b-link_button is-icon", onClick: c[0] || (c[0] = I => n.value = !0) }, [vue.createElementVNode("div", Ps, [vue.createVNode(l, { icon: vue.unref(freeSolidSvgIcons.faMagnifyingGlass) }, null, 8, ["icon"])])])])) } } }), Bs = { class: vue.normalizeClass(["icon"]) }, js = { class: vue.normalizeClass(["icon"]) }, $s = vue.defineComponent({ __name: "HorizontalScroll", props: { container: {}, scrollTo: {}, scrollPositionKey: {}, arrowStyle: {}, disableArrows: { type: Boolean }, enableWheelScroll: { type: Boolean } }, setup(e) { const t = e; function n(w) { return w.detail ? w.wheelDelta ? w.wheelDelta / w.detail / 40 * (w.detail > 0 ? 1 : -1) : -w.detail / 3 : (w.wheelDelta || 1) / 120 } function r(w, B, ne, oe = "horizontal") { let qe = !1, ke = !1, he = w.scrollLeft, _e = w.scrollLeft; function Ee(se) { se.preventDefault(); const ve = n(se); he += -ve * B, oe === "vertical" ? he = Math.max(0, Math.min(he, w.scrollHeight - w.clientHeight)) : he = Math.max(0, Math.min(he, w.scrollWidth - w.clientWidth)), ke || Oe(); } function Oe() { const se = (he - _e) / ne; ke = !0, _e = parseFloat((_e + se).toFixed(2)), w.scrollLeft = _e, Math.abs(se) > .5 ? requestAnimationFrame(Oe) : ke = !1; } function Re() { ke || (_e = he = w.scrollLeft); } function ge(se) { let ve = !1; se.wheelDeltaY ? ve = se.wheelDeltaY === (se.deltaY || 0) * -3 : se.deltaMode === 0 && (ve = !0), ve ? ze() : we(); } function we() { w.removeEventListener("mousewheel", ge), w.removeEventListener("DOMMouseScroll", ge); } function ze() { we(), qe || (w.removeEventListener("mousewheel", Ee), w.removeEventListener("DOMMouseScroll", Ee), w.removeEventListener("scroll", Re), qe = !0); } return w.addEventListener("scroll", Re, { passive: !1 }), w.addEventListener("mousewheel", ge, { passive: !1 }), w.addEventListener("DOMMouseScroll", ge, { passive: !1 }), w.addEventListener("mousewheel", Ee, { passive: !1 }), w.addEventListener("DOMMouseScroll", Ee, { passive: !1 }), we } let i = {}; const s = (w, B) => { const ne = {}; return B.forEach(oe => { oe in w && (ne[oe] = w[oe]); }), ne }, a = (w, B) => { B && (vue.nextTick(() => { i[B] && (w.value.scrollLeft = i[B]); }), vue.watchEffect(() => { const ne = Object.keys(i); i = s(i, ne.slice(0, 99)), i[B] = w.value.scrollLeft; })); }, c = vue.ref(!1), l = vue.ref({}), f = vue.reactive({ dragging: !1, pageX: 0, scrollLeft: 0 }), u = vue.reactive({ left: !1, right: !1 }); a(l, t.scrollPositionKey); const y = w => { c.value || (f.dragging = !0, f.pageX = w.pageX, f.scrollLeft = l.value.scrollLeft, document.addEventListener("mousemove", m), document.addEventListener("mouseup", I)); }, m = w => { const B = w.pageX - f.pageX; l.value.scrollLeft = f.scrollLeft - B; }, I = () => { f.dragging && (f.dragging = !1, document.removeEventListener("mousemove", m), document.removeEventListener("mouseup", I)); }, k = () => { if (l.value) { const w = l.value.offsetWidth === l.value.scrollWidth; u.left = l.value.scrollLeft >= 25; const B = l.value.scrollWidth - l.value.offsetWidth; u.right = !w && l.value.scrollLeft <= B - 25; } }, D = w => { const B = l.value.offsetWidth * .7; let ne = w === "right" ? Math.min(l.value.scrollLeft + B, l.value.scrollWidth) : Math.max(l.value.scrollLeft - B, 0); l.value.scrollTo({ left: ne, behavior: "smooth" }); }, G = (w, B) => { if (w !== void 0) { const ne = l.value.querySelector(`[data-scroll-id="${w}"]`); if (ne) { const oe = ne.offsetLeft + ne.offsetWidth / 2 - l.value.parentElement.offsetWidth / 2; l.value.scrollTo({ left: oe, behavior: B ? "smooth" : "auto" }); } } }; let v; vue.watch(() => t.scrollTo, w => { G(w, !0); }), vue.onMounted(() => { k(), G(t.scrollTo, !1), t.enableWheelScroll && (v = r(l.value, 120, 20)); }), vue.onBeforeUnmount(() => { t.enableWheelScroll && v && v(); }); const b = vue.computed(() => ({ [t.container]: !0, drag: f.dragging })), C = { arrow: !0, "is-icon": !0 }, j = vue.computed(function () { return { ...C, left: !0 } }), te = vue.computed(() => ({ ...C, right: !0 })); return (w, B) => { const ne = vue.resolveComponent("fa-icon"); return vue.openBlock(), vue.createElementBlock("div", { class: vue.normalizeClass(b.value), "data-scroll-container": "" }, [vue.createVNode(vue.Transition, { name: "fade" }, { default: vue.withCtx(() => [w.disableArrows ? vue.createCommentVNode("", !0) : vue.withDirectives((vue.openBlock(), vue.createElementBlock("div", { key: 0, class: vue.normalizeClass(j.value), onClick: B[0] || (B[0] = oe => D("left")) }, [vue.createElementVNode("div", Bs, [vue.createVNode(ne, { icon: vue.unref(freeSolidSvgIcons.faChevronLeft) }, null, 8, ["icon"])])], 2)), [[vue.vShow, u.left]])]), _: 1 }), vue.createVNode(vue.Transition, { name: "fade" }, { default: vue.withCtx(() => [w.disableArrows ? vue.createCommentVNode("", !0) : vue.withDirectives((vue.openBlock(), vue.createElementBlock("div", { key: 0, class: vue.normalizeClass(te.value), onClick: B[1] || (B[1] = oe => D("right")) }, [vue.createElementVNode("div", js, [vue.createVNode(ne, { icon: vue.unref(freeSolidSvgIcons.faChevronRight) }, null, 8, ["icon"])])], 2)), [[vue.vShow, u.right]])]), _: 1 }), vue.createElementVNode("div", { ref_key: "scrollContainer", ref: l, "data-scroll-content": "", class: vue.normalizeClass(["inner"]), onScrollPassive: k, onDragstart: B[2] || (B[2] = vue.withModifiers(() => { }, ["prevent"])), onMousedown: y, onClickCapture: B[3] || (B[3] = vue.withModifiers(() => { }, ["prevent"])) }, [vue.renderSlot(w.$slots, "default")], 544)], 2) } } }), Us = vue.defineComponent({ __name: "PlayerEpisodesList", setup(e) { const t = Ce(), { anime: n, data: r } = pinia.storeToRefs(t), i = me(), { episode: s } = pinia.storeToRefs(i), a = c => { i.isMissingEpisode(c) || i.setEpisode(c); }; return (c, l) => { const f = vue.resolveDirective("scroll-to"); return vue.openBlock(), vue.createElementBlock(vue.Fragment, null, [vue.createVNode(Fs), vue.createVNode($s, { container: "sp-episodes_container", "enable-wheel-scroll": !0, "scroll-to": vue.unref(s) }, { default: vue.withCtx(() => [(vue.openBlock(!0), vue.createElementBlock(vue.Fragment, null, vue.renderList(vue.unref(r).totalEpisodes, u => { var y, m; return vue.withDirectives((vue.openBlock(), vue.createBlock(ks, vue.mergeProps({ key: u, ref_for: !0 }, { active: vue.unref(s) === u, disabled: vue.unref(i).isMissingEpisode(u), episode: u, watched: ((m = (y = vue.unref(n)) == null ? void 0 : y.userRate) == null ? void 0 : m.episodes) === u }, { episode: u, "data-scroll-id": u, onClick: I => a(u) }), null, 16, ["episode", "data-scroll-id", "onClick"])), [[f, vue.unref(s) === u, void 0, { mounted: !0, horizontal: !0 }]]) }), 128))]), _: 1 }, 8, ["scroll-to"])], 64) } } }), Vs = { class: "subheadline" }, qs = ["data-player-sidebar"], zs = { key: 0, class: "sp-container sp-episodes" }, Gs = vue.defineComponent({ __name: "App", setup(e) { const t = Ce(), { anime: n } = pinia.storeToRefs(t), r = nt(), { hasEpisodes: i, sidebarVisible: s, sidebarHeight: a } = pinia.storeToRefs(r), c = me(), l = vue.ref("Смотреть"); t.initBalancers(); const f = y => y + (c.isMissingEpisode(y + 1) ? 0 : 1), u = vue.ref(!1); return vue.onMounted(() => { $(document).on("ajax:success", () => { var m, I; const y = $(".b-user_rate.anime-" + n.value.id); if (n.value.userRate = (m = y.data("view_object")) == null ? void 0 : m.model, (I = n.value.userRate) != null && I.episodes) { let k = f(n.value.userRate.episodes); k > n.value.episodes && (k = n.value.userRate.episodes), c.setEpisode(k); } }), getComputedStyle(document.documentElement).getPropertyValue("--color-text-hint") && (u.value = !0); }), (y, m) => (vue.openBlock(), vue.createElementBlock(vue.Fragment, null, [vue.createElementVNode("div", Vs, vue.toDisplayString(l.value), 1), vue.createElementVNode("div", { class: vue.normalizeClass(["block", { boop: u.value }]) }, [vue.createElementVNode("div", { class: vue.normalizeClass(["sp-container", "sp-content", { "max-height": vue.unref(a) }]), "data-player-sidebar": vue.unref(s) ? "visible" : "hidden", "data-player-container": "" }, [vue.createVNode(Hr), vue.createVNode(ys)], 10, qs), vue.unref(i) ? (vue.openBlock(), vue.createElementBlock("div", zs, [vue.createVNode(Us)])) : vue.createCommentVNode("", !0), vue.createVNode(Ts)], 2)], 64)) } }); function sn(e, t) { let n = e.parentElement; for (let a = 0; a < 3 && !(!n || n.scrollHeight > n.clientHeight || n.scrollWidth > n.clientWidth); a++)n = n.parentElement; if (!n) return; const r = e.getBoundingClientRect(), i = n.getBoundingClientRect(), s = { behavior: t.modifiers.smooth ? "smooth" : "auto" }; (t.modifiers.vertical || !t.modifiers.horizontal) && (s.top = r.top - i.top + n.scrollTop - i.height / 2 + r.height / 2), (t.modifiers.horizontal || !t.modifiers.vertical) && (s.left = r.left - i.left + n.scrollLeft - i.width / 2 + r.width / 2), n.scrollTo(s); } const Hs = { updated: (e, t) => { !t.modifiers.updated || !t.value || sn(e, t); }, mounted: (e, t) => { !t.modifiers.mounted || !t.value || sn(e, t); } }; let ye; class Ws { constructor() { } render() { const t = pinia.createPinia(); ye = vue.createApp(Gs), ye.use(t), ye.directive("scroll-to", Hs), ye.component("FaIcon", xi); const n = $("<div>", { id: "shiki_player", class: "cc shiki-player" }); $(".p-animes .b-db_entry").after(n), ye.mount(n.get()[0]); } destroy() { var t; (t = document.getElementById("shiki_player")) == null || t.remove(), ye == null || ye.unmount(); } } let ft; fn({ init() { ft = new Ws; }, events: [{ preconditions: { predicates: [() => !!document.getElementById("animes_show") && !document.getElementById("shiki_player")] }, target: document, type: ["page:load", "turbolinks:load", ["attachEvent", "DOMContentLoaded"]], listener: async () => { ft.render(); } }, { preconditions: { predicates: [() => !!document.getElementById("shiki_player")] }, target: document, type: "turbolinks:before-cache", listener: () => { ft.destroy(); } }] });

})(Vue, Pinia, window["fontawesome-svg-core"], window["free-solid-svg-icons"], KodikWrapper, window["free-regular-svg-icons"]);